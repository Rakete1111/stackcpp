// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.



#ifndef STACKCPP_PARSER_IMPL_HPP
#define STACKCPP_PARSER_IMPL_HPP

#include "stackcpp/misc/exceptions.h"
#include "stackcpp/misc/types.hpp"
#include "stackcpp/misc/flags.hpp"

#include <rapidjson/document.h>
#include <string>



namespace stackcpp {

namespace {

// Helper function to update a field of an object.
template<typename T, typename F, typename... Fs> void update_field(T& field, const rapidjson::Value& properties, const char* name, F&& parser, Fs&&... arguments) {
    auto it = properties.MemberEnd();
    if ((it = properties.FindMember(name)) != properties.MemberEnd())
        field = parser(it->value, std::forward<Fs>(arguments)...);
}



// Parses an integer from a given value.
integer_t parse_integer(const rapidjson::Value& integer) {
    if (!integer.IsInt64())
        throw invalid_json_value{"integer"};
    return static_cast<integer_t>(integer.GetInt64());
}

// Parses a date from a given value.
date_t parse_date(const rapidjson::Value& date) {
    if (!date.IsInt64())
        throw invalid_json_value{"unix epoch time (integer)"};
    return std::chrono::system_clock::from_time_t(date.GetInt64());
}

decimal_t parse_decimal(const rapidjson::Value& decimal) {
    if (!decimal.IsDouble())
        throw invalid_json_value{"decimal"};
    return static_cast<decimal_t>(decimal.GetDouble());
}

// Parses a string from a given value.
std::string parse_string(const rapidjson::Value& string) {
    if (!string.IsString())
        throw invalid_json_value{"string"};
    return string.GetString();
}

// Parses a boolean from a given value.
bool parse_bool(const rapidjson::Value& boolean) {
    if (!boolean.IsBool())
        throw invalid_json_value{"boolean"};
    return boolean.GetBool();
}

unique_id parse_unique_id(const rapidjson::Value& id) {
    if (!id.IsUint64())
        throw invalid_json_value{"unique_id"};
    return unique_id{static_cast<unique_id::type>(id.GetUint64())};
}

// Parses string to a user type.
user_type parse_user_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "unregistered")
        return user_type::unregistered;
    if (type_str == "registered")
        return user_type::registered;
    if (type_str == "moderator")
        return user_type::moderator;
    if (type_str == "does_not_exist")
        return user_type::does_not_exist;
    throw unknown_enum_string{"user", type_str};
}

// Parses string to a post type.
post_type parse_post_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "question")
        return post_type::question;
    if (type_str == "answer")
        return post_type::answer;
    throw unknown_enum_string{"post", type_str};
}

// Parses string to a badge type.
badge_type parse_badge_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "named")
        return badge_type::named;
    if (type_str == "tag_based")
        return badge_type::tag_based;
    throw unknown_enum_string{"badge", type_str};
}

// Parses string to a badge rank.
badge_rank parse_badge_rank(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "bronze")
        return badge_rank::bronze;
    if (type_str == "silver")
        return badge_rank::silver;
    if (type_str == "gold")
        return badge_rank::gold;
    throw unknown_enum_string{"badge rank", type_str};
}

site_state parse_site_state(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "normal")
        return site_state::normal;
    if (type_str == "closed_beta")
        return site_state::closed_beta;
    if (type_str == "open_beta")
        return site_state::open_beta;
    if (type_str == "linked_meta")
        return site_state::linked_meta;
    throw unknown_enum_string{"site state", type_str};
}

activity_type parse_activity_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "question_posted")
        return activity_type::question_posted;
    if (type_str == "answer_posted")
        return activity_type::answer_posted;
    if (type_str == "badge_earned")
        return activity_type::badge_earned;
    if (type_str == "comment_posted")
        return activity_type::comment_posted;
    throw unknown_enum_string{"activity", type_str};
}

vote_type parse_vote_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "accepts")
        return vote_type::accept;
    if (type_str == "up_votes")
        return vote_type::upvote;
    if (type_str == "down_votes")
        return vote_type::downvote;
    if (type_str == "bounties_offered")
        return vote_type::bounty_offered;
    if (type_str == "bounties_won")
        return vote_type::bounty_won;
    if (type_str == "spam")
        return vote_type::spam;
    if (type_str == "suggested_edits")
        return vote_type::suggested_edit;
    throw unknown_enum_string{"vote", type_str};
}

notification_type parse_notification_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "generic")
        return notification_type::generic;
    if (type_str == "profile_activity")
        return notification_type::profile_activity;
    if (type_str == "bounty_expired")
        return notification_type::bounty_expired;
    if (type_str == "bounty_expires_in_one_day")
        return notification_type::bounty_expires_in_one_day;
    if (type_str == "badge_earned")
        return notification_type::badge_earned;
    if (type_str == "bounty_expires_in_three_days")
        return notification_type::bounty_expires_in_three_days;
    if (type_str == "reputation_bonus")
        return notification_type::reputation_bonus;
    if (type_str == "accounts_associated")
        return notification_type::accounts_associated;
    if (type_str == "new_privilege")
        return notification_type::new_privilege;
    if (type_str == "post_migrated")
        return notification_type::post_migrated;
    if (type_str == "moderator_message")
        return notification_type::moderator_message;
    if (type_str == "registration_reminder")
        return notification_type::registration_reminder;
    if (type_str == "edit_suggested")
        return notification_type::edit_suggested;
    if (type_str == "substantive_edit")
        return notification_type::substantive_edit;
    if (type_str == "bounty_grace_period_started")
        return notification_type::bounty_grace_period_started;
    throw unknown_enum_string{"notification", type_str};
}

reputation_history_type parse_reputation_history_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "asker_accepts_answer")
        return reputation_history_type::asker_accepts_answer;
    if (type_str == "asker_unaccept_answer")
        return reputation_history_type::asker_unaccepts_answer;
    if (type_str == "answer_accepted")
        return reputation_history_type::answer_accepted;
    if (type_str == "answer_unaccepted")
        return reputation_history_type::answer_unaccepted;
    if (type_str == "voter_downvotes")
        return reputation_history_type::voter_downvotes;
    if (type_str == "voter_undownvotes")
        return reputation_history_type::voter_undownvotes;
    if (type_str == "post_downvoted")
        return reputation_history_type::post_downvoted;
    if (type_str == "post_undownvoted")
        return reputation_history_type::post_undownvoted;
    if (type_str == "post_upvoted")
        return reputation_history_type::post_upvoted;
    if (type_str == "post_unupvoted")
        return reputation_history_type::post_unupvoted;
    if (type_str == "suggested_edit_approval_received")
        return reputation_history_type::suggested_edit_approved;
    if (type_str == "post_flagged_as_spam")
        return reputation_history_type::post_flagged_as_spam;
    if (type_str == "post_flagged_as_offensive")
        return reputation_history_type::post_flagged_as_offensive;
    if (type_str == "bounty_given")
        return reputation_history_type::bounty_given;
    if (type_str == "bounty_earned")
        return reputation_history_type::bounty_earned;
    if (type_str == "bounty_cancelled")
        return reputation_history_type::bounty_cancelled;
    if (type_str == "post_deleted")
        return reputation_history_type::post_deleted;
    if (type_str == "post_undeleted")
        return reputation_history_type::post_undeleted;
    if (type_str == "association_bonus")
        return reputation_history_type::association_bonus;
    if (type_str == "arbitrary_reputation_change")
        return reputation_history_type::arbitrary_reputation_change;
    if (type_str == "vote_fraud_reversal")
        return reputation_history_type::vote_fraud_reversal;
    if (type_str == "post_migrated")
        return reputation_history_type::post_migrated;
    if (type_str == "user_deleted")
        return reputation_history_type::user_deleted;
    if (type_str == "example_upvoted")
        return reputation_history_type::example_upvoted;
    if (type_str == "example_unupvoted")
        return reputation_history_type::example_unupvoted;
    if (type_str == "proposed_change_approved")
        return reputation_history_type::proposed_change_approved;
    if (type_str == "doc_link_upvoted")
        return reputation_history_type::doc_link_upvoted;
    if (type_str == "doc_link_unupvoted")
        return reputation_history_type::doc_link_unupvoted;
    if (type_str == "doc_source_removed")
        return reputation_history_type::doc_source_removed;
    if (type_str == "suggested_edit_approval_overridden")
        return reputation_history_type::suggested_edit_approval_overridden;
    throw unknown_enum_string{"history", type_str};
}

user_timeline_type parse_user_timeline_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "commented")
        return user_timeline_type::commented;
    if (type_str == "asked")
        return user_timeline_type::asked;
    if (type_str == "answered")
        return user_timeline_type::answered;
    if (type_str == "badge")
        return user_timeline_type::badge;
    if (type_str == "revision")
        return user_timeline_type::revision;
    if (type_str == "accepted")
        return user_timeline_type::accepted;
    if (type_str == "reviewed")
        return user_timeline_type::reviewed;
    if (type_str == "suggested")
        return user_timeline_type::suggested;
    throw unknown_enum_string{"user timeline", type_str};
}

item_type parse_item_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "comment")
        return item_type::comment;
    if (type_str == "chat_message")
        return item_type::chat_message;
    if (type_str == "new_answer")
        return item_type::new_answer;
    if (type_str == "careers_message")
        return item_type::careers_message;
    if (type_str == "careers_invitations")
        return item_type::careers_invitations;
    if (type_str == "meta_question")
        return item_type::meta_question;
    if (type_str == "post_notice")
        return item_type::post_notice;
    if (type_str == "moderator_message")
        return item_type::moderator_message;
    throw unknown_enum_string{"item", type_str};
}

event_type parse_event_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "question_posted")
        return event_type::question_posted;
    if (type_str == "answer_posted")
        return event_type::answer_posted;
    if (type_str == "comment_posted")
        return event_type::comment_posted;
    if (type_str == "post_edited")
        return event_type::post_edited;
    if (type_str == "user_created")
        return event_type::user_created;
    throw unknown_enum_string{"event", type_str};
}

revision_type parse_revision_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "single_user")
        return revision_type::single_user;
    if (type_str == "vote_based")
        return revision_type::vote_based;
    throw unknown_enum_string{"revision", type_str};
}

question_timeline_type parse_question_timeline_type(const rapidjson::Value& type) {
    const auto type_str = parse_string(type);

    if (type_str == "question")
        return question_timeline_type::question;
    if (type_str == "answer")
        return question_timeline_type::answer;
    if (type_str == "comment")
        return question_timeline_type::comment;
    if (type_str == "unaccepted_answer")
        return question_timeline_type::unaccepted_answer;
    if (type_str == "accepted_answer")
        return question_timeline_type::accepted_answer;
    if (type_str == "vote_aggregate")
        return question_timeline_type::vote_aggregate;
    if (type_str == "revision")
        return question_timeline_type::revision;
    if (type_str == "post_state_changed")
        return question_timeline_type::post_state_changed;
    throw unknown_enum_string{"question_timeline", type_str};
}

// Parses an array of an unspecified type.
template<typename T> std::vector<T> parse_array(const rapidjson::Value& array, T (*parser)(const rapidjson::Value&)) {
    if (!array.IsArray())
        throw invalid_json_value{"JSON array"};

    std::vector<T> results;
    for (rapidjson::SizeType i = 0; i < array.Size(); ++i)
        results.push_back(parser(array[i]));
    return results;
}
}
}

#endif
