// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.



#ifndef STACKCPP_FLAGS_HPP
#define STACKCPP_FLAGS_HPP

#include <type_traits>



// Horrible macro to enable (binary) operations on enums.
#define STACKCPP_DEF_OPS(enum_type)                                                                                \
    constexpr enum_type operator&(const enum_type& lhs, const enum_type& rhs) noexcept {                           \
        using type = typename std::underlying_type<enum_type>::type;                                               \
        return static_cast<enum_type>(static_cast<type>(lhs) & static_cast<type>(rhs));                            \
    }                                                                                                              \
    constexpr enum_type operator|(const enum_type& lhs, const enum_type& rhs) noexcept {                           \
        using type = typename std::underlying_type<enum_type>::type;                                               \
        return static_cast<enum_type>(static_cast<type>(lhs) | static_cast<type>(rhs));                            \
    }                                                                                                              \
    constexpr bool operator==(const enum_type& lhs, typename std::underlying_type<enum_type>::type rhs) noexcept { \
        return static_cast<typename std::underlying_type<enum_type>::type>(lhs) == rhs;                            \
    }                                                                                                              \
    constexpr bool operator!=(const enum_type& lhs, typename std::underlying_type<enum_type>::type rhs) noexcept { return !(lhs == rhs); }



namespace stackcpp {

enum class sites {
#include "stackcpp/sites/list.txt"
};

enum class post_type { question, answer };

enum struct event_type { question_posted, answer_posted, comment_posted, post_edited, user_created };

enum struct item_type { unknown, comment, chat_message, new_answer, careers_message, careers_invitations, meta_question, post_notice, moderator_message };

enum struct activity_type { question_posted, answer_posted, badge_earned, comment_posted };

enum struct notification_type {
    generic,
    profile_activity,
    bounty_expired,
    bounty_expires_in_one_day,
    badge_earned,
    bounty_expires_in_three_days,
    reputation_bonus,
    accounts_associated,
    new_privilege,
    post_migrated,
    moderator_message,
    registration_reminder,
    edit_suggested,
    substantive_edit,
    bounty_grace_period_started
};

enum struct question_timeline_type { question, answer, comment, unaccepted_answer, accepted_answer, vote_aggregate, revision, post_state_changed };

enum struct reputation_history_type {
    asker_accepts_answer,
    asker_unaccepts_answer,
    answer_accepted,
    answer_unaccepted,
    voter_downvotes,
    voter_undownvotes,
    post_downvoted,
    post_undownvoted,
    post_upvoted,
    post_unupvoted,
    suggested_edit_approved,
    post_flagged_as_spam,
    post_flagged_as_offensive,
    bounty_given,
    bounty_earned,
    bounty_cancelled,
    post_deleted,
    post_undeleted,
    association_bonus,
    arbitrary_reputation_change,
    vote_fraud_reversal,
    post_migrated,
    user_deleted,
    example_upvoted,
    example_unupvoted,
    proposed_change_approved,
    doc_link_upvoted,
    doc_link_unupvoted,
    doc_source_removed,
    suggested_edit_approval_overridden
};

enum struct vote_type { accept, upvote, downvote, bounty_offered, bounty_won, spam, suggested_edit };

enum struct revision_type { single_user, vote_based };

enum class site_state { normal, closed_beta, open_beta, linked_meta };

enum struct site_type : unsigned int { main = 0x1, meta = 0x2 };

enum struct period { all_time, month };

enum struct user_timeline_type { commented, asked, answered, badge, revision, accepted, reviewed, suggested };

enum class user_type { unregistered, registered, moderator, does_not_exist };

enum struct user_sort { reputation, creation_date, display_name, modified_date };

enum struct answer_sort { activity, creation_date, votes };

enum struct badge_sort { rank, name, type, awarded_date };

enum struct comment_sort { creation_date, votes };

enum struct favorite_sort { last_activity, creation_date, votes, added };

enum struct activity_sort : unsigned int { none = 0x0, post = 0x1, badge = 0x2, comment = 0x4 };

enum struct post_sort { activity, creation, score };

enum struct question_sort { activity, creation, score, hot, week, month, rank };

enum struct suggested_edit_sort { creation, approval, rejection };

enum struct tag_sort { count, activity, name };

enum struct search_sort { activity, creation, score, relevance };

enum struct synonym_sort { creation, applied_count, activity };

enum struct badge_rank { bronze, silver, gold };

enum struct badge_type { named, tag_based };

enum struct query_order { descending, ascending };



STACKCPP_DEF_OPS(site_type)
STACKCPP_DEF_OPS(activity_sort)
}

#endif
