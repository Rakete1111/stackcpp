// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.



#define CATCH_CONFIG_MAIN
#include "catch.hpp"

#include "stackcpp/helpers/parser-impl.hpp"
#include "stackcpp/misc/exceptions.h"
#include "stackcpp/parser.h"
#include "stackcpp/restrict.h"

#include <chrono>
#include <rapidjson/document.h>
#include <string>



using namespace stackcpp::literals;



namespace {

long long to_seconds(const stackcpp::date_t& time) noexcept {
    return std::chrono::duration_cast<std::chrono::seconds>(time.time_since_epoch()).count();
}

rapidjson::Document object;
}


TEST_CASE("Access tokens can be parsed correctly.", "[parser][access-token]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "access_token": "easyTOKEN24",
    "account_id": 240500,
    "expires_on_date": 1398461083,
    "scope": ["write_access"]
})").HasParseError());

    const auto access_token = stackcpp::parse_access_token(object);
    CHECK(access_token.token() == "easyTOKEN24");
    CHECK(access_token.id() == 240500);
    CHECK(to_seconds(access_token.expires()) == 1398461083);
    CHECK(access_token.scope().at(0) == "write_access");
}



TEST_CASE("Account merges can be parsed correctly.", "[parser][account-merge]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "merge_date": 418340139,
    "new_account_id": 20242024,
    "old_account_id": 111111
})").HasParseError());

    const auto account_merge = stackcpp::parse_account_merge(object);
    CHECK(to_seconds(account_merge.merge()) == 418340139);
    CHECK(account_merge.new_account() == 20242024);
    CHECK(account_merge.old_account() == 111111);
}



TEST_CASE("Answers can be parsed correctly.", "[parser][answer]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "accepted": false,
    "answer_id": 6481,
    "awarded_bounty_amount": 100000,
    "awarded_bounty_users": [{ "display_name": "ImRich" }],
    "body": "Use jQuery! It's great and does everything!",
    "body_markdown": "Use [jQuery](https://jquery.com/)! It's **great** and does *everything*!",
    "can_flag": true,
    "comment_count": 1,
    "comments": [{ "body": "+1 for mentioning jQuery" }],
    "community_owned_date": 3154,
    "creation_date": 1355314332,
    "down_vote_count": 1,
    "downvoted": true,
    "is_accepted": true,
    "last_activity_date": 1489415418,
    "last_edit_date": 1489415418,
    "last_editor": { "user_id": 1010 },
    "link": "https://stackoverflow.com/a/6481/",
    "locked_date": 9368154,
    "owner": { "user_id": 3841949 },
    "question_id": 3748,
    "score": 16301,
    "share_link": "https://stackoverflow.com/a/6481/",
    "tags": ["javascript"],
    "title": "How can I add 2 numbers?",
    "up_vote_count": 16301,
    "upvoted": true
})").HasParseError());

    const auto answer = stackcpp::parse_answer(object);
    CHECK_FALSE(answer.has_accepted());
    CHECK(answer.id() == 6481);
    CHECK(answer.bounty() == 100000);
    CHECK(answer.bounty_receivers().at(0).name() == "ImRich");
    CHECK(answer.content() == "Use jQuery! It's great and does everything!");
    CHECK(answer.content_markdown() == "Use [jQuery](https://jquery.com/)! It's **great** and does *everything*!");
    CHECK(answer.flag());
    CHECK(answer.comments().at(0).content() == "+1 for mentioning jQuery");
    CHECK(to_seconds(answer.community_wiki()) == 3154);
    CHECK(to_seconds(answer.creation()) == 1355314332);
    CHECK(answer.downvotes() == 1);
    CHECK(answer.has_downvoted());
    CHECK(answer.accepted());
    CHECK(to_seconds(answer.last_active()) == 1489415418);
    CHECK(to_seconds(answer.last_edited()) == 1489415418);
    CHECK(answer.last_editor().id() == 1010);
    CHECK(answer.url() == "https://stackoverflow.com/a/6481/");
    CHECK(to_seconds(answer.locked()) == 9368154);
    CHECK(answer.owner().id() == 3841949);
    CHECK(answer.question_id() == 3748);
    CHECK(answer.score() == 16301);
    CHECK(answer.share_url() == "https://stackoverflow.com/a/6481/");
    CHECK(answer.tags().at(0) == "javascript");
    CHECK(answer.upvotes() == 16301);
    CHECK(answer.has_upvoted());
}



TEST_CASE("Badge counts can be parsed correctly.", "[parser][badge-count]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "bronze": 11,
    "silver": 22,
    "gold": 33
})").HasParseError());

    const auto badges = stackcpp::parse_badge_count(object);
    CHECK(badges.bronze() == 11);
    CHECK(badges.silver() == 22);
    CHECK(badges.gold() == 33);
}



TEST_CASE("Badges can be parsed correctly.", "[parser][badge]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "award_count": 1,
    "badge_id": 49,
    "badge_type": "named",
    "description": "The best tag in the world!",
    "link": "https://stackoverflow.com/badges/49/c++",
    "name": "c++",
    "rank": "gold",
    "user": { "display_name": "Bjarne Stroustrup" }
})").HasParseError());

    const auto badge = stackcpp::parse_badge(object);
    CHECK(badge.amount() == 1);
    CHECK(badge.id() == 49);
    CHECK(badge.type() == stackcpp::badge_type::named);
    CHECK(badge.description() == "The best tag in the world!");
    CHECK(badge.url() == "https://stackoverflow.com/badges/49/c++");
    CHECK(badge.name() == "c++");
    CHECK(badge.rank() == stackcpp::badge_rank::gold);
    CHECK(badge.user().name() == "Bjarne Stroustrup");
}



TEST_CASE("Closed details can be parsed correctly.", "[parser][closed-detail]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "by_users": [{ "display_name": "ILikeClosingQuestions" }],
    "description": "This question has been closed because we say so.",
    "on_hold": true,
    "original_questions": [{ "title": "Why are we better than you?" }],
    "reason": "duplicate"
})").HasParseError());

    const auto details = stackcpp::parse_closed_detail(object);
    CHECK(details.users().at(0).name() == "ILikeClosingQuestions");
    CHECK(details.description() == "This question has been closed because we say so.");
    CHECK(details.on_hold());
    CHECK(details.original_questions().at(0).title() == "Why are we better than you?");
    CHECK(details.reason() == "duplicate");
}



TEST_CASE("Comments can be parsed correctly.", "[parser][comment]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "body": "+1 Because you used English (I've seen too many French answers lately)...",
    "body_markdown": "+1 Because you used **English** (I've seen too many *French* answers lately)...",
    "can_flag": true,
    "comment_id": 5242017,
    "creation_date": 951614667,
    "edited": true,
    "link": "https://stackoverflow.com/comments/5242017",
    "owner": { "display_name": "GermanGuy" },
    "post_id": 2275482,
    "post_type": "answer",
    "reply_to_user": { "display_name": "EnglishGal" },
    "score": 452,
    "upvoted": true
})").HasParseError());

    const auto comment = stackcpp::parse_comment(object);
    CHECK(comment.content() == "+1 Because you used English (I've seen too many French answers lately)...");
    CHECK(comment.content_markdown() == "+1 Because you used **English** (I've seen too many *French* answers lately)...");
    CHECK(comment.flag());
    CHECK(comment.id() == 5242017);
    CHECK(to_seconds(comment.creation()) == 951614667);
    CHECK(comment.edited());
    CHECK(comment.url() == "https://stackoverflow.com/comments/5242017");
    CHECK(comment.owner().name() == "GermanGuy");
    CHECK(comment.post_id() == 2275482);
    CHECK(comment.post_type() == stackcpp::post_type::answer);
    CHECK(comment.reply_to().name() == "EnglishGal");
    CHECK(comment.score() == 452);
    CHECK(comment.has_upvoted());
}



TEST_CASE("Events can be parsed correctly.", "[parser][event]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "creation_date": 980089,
    "event_id": 110011,
    "event_type": "user_created",
    "excerpt": "A random user has been created!",
    "link": "https://stackoverflow.com/users/110011/a-random-user"
})").HasParseError());

    const auto event = stackcpp::parse_event(object);
    CHECK(to_seconds(event.creation()) == 980089);
    CHECK(event.id() == 110011);
    CHECK(event.type() == stackcpp::event_type::user_created);
    CHECK(event.excerpt() == "A random user has been created!");
    CHECK(event.url() == "https://stackoverflow.com/users/110011/a-random-user");
}



TEST_CASE("Flag options can be parsed correctly.", "[parser][flag-option]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "count": 99,
    "description": "Use if you don't like a user.",
    "dialog_title": "I hate this user!",
    "has_flagged": true,
    "option_id": 1,
    "requires_comment": true,
    "requires_question_id": true,
    "requires_site": true,
    "sub_options": [{ "description": "Use if you *really* hate a user." }],
    "title": "This user should be banned."
})").HasParseError());

    const auto option = stackcpp::parse_flag_option(object);
    CHECK(option.count() == 99);
    CHECK(option.description() == "Use if you don't like a user.");
    CHECK(option.dialog_title() == "I hate this user!");
    CHECK(option.has_flagged());
    CHECK(option.id() == 1);
    CHECK(option.requires_comment());
    CHECK(option.requires_question_id());
    CHECK(option.requires_site());
    CHECK(option.sub_flags().at(0).description() == "Use if you *really* hate a user.");
}



TEST_CASE("Inbox items can be parsed correctly.", "[parser][inbox-item]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "answer_id": 545,
    "body": "ANSWER ME!!!!!!!",
    "comment_id": 8845100,
    "creation_date": 110400,
    "is_unread": true,
    "item_type": "chat_message",
    "link": "https://chat.stackoverflow.com/comment/8845100",
    "question_id": 4800,
    "site": { "name": "StackOverflow" },
    "title": "Y u NO answer ME?!?!?"
})").HasParseError());

    const auto item = stackcpp::parse_inbox_item(object);
    CHECK(item.answer_id() == 545);
    CHECK(item.content() == "ANSWER ME!!!!!!!");
    CHECK(item.comment_id() == 8845100);
    CHECK(to_seconds(item.creation()) == 110400);
    CHECK(item.unread());
    CHECK(item.type() == stackcpp::item_type::chat_message);
    CHECK(item.url() == "https://chat.stackoverflow.com/comment/8845100");
    CHECK(item.question_id() == 4800);
    CHECK(item.site().name() == "StackOverflow");
    CHECK(item.title() == "Y u NO answer ME?!?!?");
}



TEST_CASE("Infos can be parsed correctly.", "[parser][info]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "answers_per_minute": 13.37,
    "api_revision": "2.2.2.2",
    "badges_per_minute": 0.1,
    "new_active_users": 1,
    "questions_per_minute": 0.5,
    "site": { "name": "PerfectOverflow" },
    "total_accepted": 39104,
    "total_answers": 1380000,
    "total_badges": 48190,
    "total_comments": 1,
    "total_questions": 39103,
    "total_unanswered": 1,
    "total_users": 17,
    "total_votes": 6666
})").HasParseError());

    const auto info = stackcpp::parse_info(object);
    CHECK(info.answers_per_minute() == Approx(13.37));
    CHECK(info.api_revision() == "2.2.2.2");
    CHECK(info.badges_per_minute() == Approx(.1));
    CHECK(info.new_active_users() == 1);
    CHECK(info.questions_per_minute() == Approx(.5));
    CHECK(info.site().name() == "PerfectOverflow");
    CHECK(info.accepted() == 39104);
    CHECK(info.answers() == 1380000);
    CHECK(info.badges() == 48190);
    CHECK(info.comments() == 1);
    CHECK(info.questions() == 39103);
    CHECK(info.unanswered() == 1);
    CHECK(info.users() == 17);
    CHECK(info.votes() == 6666);
}



TEST_CASE("Migration infos can be parsed correctly.", "[parser][migration-info]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "on_date": 12122012,
    "other_site": { "name": "RandomOverflow" },
    "question_id": 123456789
})").HasParseError());

    const auto info = stackcpp::parse_migration_info(object);
    CHECK(to_seconds(info.date()) == 12122012);
    CHECK(info.other_site().name() == "RandomOverflow");
    CHECK(info.question_id() == 123456789);
}



TEST_CASE("Network activities can be parsed correctly.", "[parser][network-activity]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "account_id": 772477,
    "activity_type": "answer_posted",
    "api_site_parameter": "random",
    "badge_id": 1,
    "creation_date": 227744,
    "description": "A random answer has been posted!",
    "link": "https://stackoverflow.com/answer/random",
    "post_id": 502405,
    "score": 1024,
    "tags": ["random"],
    "title": "How can I be random?"
})").HasParseError());

    const auto activity = stackcpp::parse_network_activity(object);
    CHECK(activity.account_id() == 772477);
    CHECK(activity.activity() == stackcpp::activity_type::answer_posted);
    CHECK(activity.api_site() == "random");
    CHECK(activity.badge_id() == 1);
    CHECK(to_seconds(activity.creation()) == 227744);
    CHECK(activity.description() == "A random answer has been posted!");
    CHECK(activity.url() == "https://stackoverflow.com/answer/random");
    CHECK(activity.post_id() == 502405);
    CHECK(activity.score() == 1024);
    CHECK(activity.tags().at(0) == "random");
    CHECK(activity.title() == "How can I be random?");
}



TEST_CASE("Network posts can be parsed correctly.", "[parser][network-post]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "post_id": 1922,
    "post_type": "answer",
    "score": 2017,
    "title": "Don't use Javascript, use jQuery (it's a language now)!"
})").HasParseError());

    const auto post = stackcpp::parse_network_post(object);
    CHECK(post.id() == 1922);
    CHECK(post.type() == stackcpp::post_type::answer);
    CHECK(post.score() == 2017);
    CHECK(post.title() == "Don't use Javascript, use jQuery (it's a language now)!");
}



TEST_CASE("Network users can be parsed correctly.", "[parser][network-user]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "account_id": 112233,
    "answer_count": 1,
    "badge_counts": { "gold": 318 },
    "creation_date": 384718903,
    "last_access_date": 1739414939,
    "question_count": 3941,
    "reputation": 30134,
    "site_name": "LazyOverflow",
    "site_url": "https://lazyoverflow.com/",
    "top_answers": [{ "score": -10 }],
    "top_questions": [{ "score": 14038 }],
    "user_id": 78410,
    "user_type": "registered"
})").HasParseError());

    const auto user = stackcpp::parse_network_user(object);
    CHECK(user.account_id() == 112233);
    CHECK(user.answers() == 1);
    CHECK(user.badges().gold() == 318);
    CHECK(to_seconds(user.creation()) == 384718903);
    CHECK(to_seconds(user.last_accessed()) == 1739414939);
    CHECK(user.questions() == 3941);
    CHECK(user.reputation() == 30134);
    CHECK(user.site() == "LazyOverflow");
    CHECK(user.site_url() == "https://lazyoverflow.com/");
    CHECK(user.top_answers().at(0).score() == -10);
    CHECK(user.top_questions().at(0).score() == 14038);
    CHECK(user.id() == 78410);
    CHECK(user.type() == stackcpp::user_type::registered);
}



TEST_CASE("Notices can be parsed correctly.", "[parser][notice]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "body": "Warning: Please do not visit StackOverflow anymore...",
    "creation_date": 1,
    "owner_user_id": 1
})").HasParseError());

    const auto notice = stackcpp::parse_notice(object);
    CHECK(notice.content() == "Warning: Please do not visit StackOverflow anymore...");
    CHECK(to_seconds(notice.creation()) == 1);
    CHECK(notice.owner_id() == 1);
}



TEST_CASE("Notifications can be parsed correctly.", "[parser][notification]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "body": "No. You cannot change a type in C++, full stop.",
    "creation_date": 1500000000,
    "is_unread": true,
    "notification_type": "moderator_message",
    "post_id": 380481,
    "site": { "name": "StackOverflow" }
})").HasParseError());

    const auto notification = stackcpp::parse_notification(object);
    CHECK(notification.content() == "No. You cannot change a type in C++, full stop.");
    CHECK(to_seconds(notification.creation()) == 1500000000);
    CHECK(notification.unread());
    CHECK(notification.type() == stackcpp::notification_type::moderator_message);
    CHECK(notification.post_id() == 380481);
    CHECK(notification.site().name() == "StackOverflow");
}



TEST_CASE("Original questions can be parsed correctly.", "[parser][original-question]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "accepted_answer_id": 15511551,
    "answer_count": 10,
    "question_id": 49014,
    "title": "How can I do this without doing that?"
})").HasParseError());

    const auto question = stackcpp::parse_original_question(object);
    CHECK(question.accepted_answer_id() == 15511551);
    CHECK(question.answers() == 10);
    CHECK(question.id() == 49014);
    CHECK(question.title() == "How can I do this without doing that?");
}



TEST_CASE("Posts can be parsed correctly.", "[parser][post]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "body": "here my profesional qestion: can i create a obgect in c++8??? is this even posiblle. Show me howwww",
    "body_markdown": "#here my **profesional qestion**: **can i create a obgect in c++8**??? is this *even* posiblle. #Show me howwww",
    "comment_count": 1,
    "comments": [{ "body": "Who in the world upvoted this? Please, both of you, go read a good book." }],
    "creation_date": 20172017,
    "down_vote_count": 381,
    "downvoted": true,
    "last_activity_date": 20202020,
    "last_edit_date": 20182018,
    "last_editor": { "display_name": "user1089238014" },
    "link": "https://stackoverflow.com/q/77744",
    "owner": { "display_name": "ExPeRt" },
    "post_id": 77744,
    "post_type": "question",
    "score": -380,
    "share_link": "https://weird.question",
    "title": "profesional qestion",
    "up_vote_count": 1,
    "upvoted": true
})").HasParseError());

    const auto post = stackcpp::parse_post(object);
    CHECK(post.content() == "here my profesional qestion: can i create a obgect in c++8??? is this even posiblle. Show me howwww");
    CHECK(post.content_markdown() == "#here my **profesional qestion**: **can i create a obgect in c++8**??? is this *even* posiblle. #Show me howwww");
    CHECK(post.comments().at(0).content() == "Who in the world upvoted this? Please, both of you, go read a good book.");
    CHECK(to_seconds(post.creation()) == 20172017);
    CHECK(post.downvotes() == 381);
    CHECK(post.has_downvoted());
    CHECK(to_seconds(post.last_active()) == 20202020);
    CHECK(to_seconds(post.last_edited()) == 20182018);
    CHECK(post.last_editor().name() == "user1089238014");
    CHECK(post.url() == "https://stackoverflow.com/q/77744");
    CHECK(post.owner().name() == "ExPeRt");
    CHECK(post.id() == 77744);
    CHECK(post.type() == stackcpp::post_type::question);
    CHECK(post.score() == -380);
    CHECK(post.share_url() == "https://weird.question");
    CHECK(post.title() == "profesional qestion");
    CHECK(post.upvotes() == 1);
    CHECK(post.has_upvoted());
}



TEST_CASE("Privileges can be parsed correctly.", "[parser][privilege]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "description": "Allows you to answer a question.",
    "reputation": 25000,
    "short_description": "Answer a question."
})").HasParseError());

    const auto privilege = stackcpp::parse_privilege(object);
    CHECK(privilege.description() == "Allows you to answer a question.");
    CHECK(privilege.reputation() == 25000);
    CHECK(privilege.short_description() == "Answer a question.");
}



TEST_CASE("Question timeline can be parsed correctly.", "[parser][question-timeline]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "comment_id": 4333,
    "creation_date": 5483104,
    "down_vote_count": 10,
    "owner": { "display_name": "user192835483" },
    "post_id": 874831,
    "question_id": 874831,
    "revision_guid": "5ABC480-FADBCD8",
    "timeline_type": "question",
    "up_vote_count": 305,
    "user": { "display_name": "aUser" }
})").HasParseError());

    const auto timeline = stackcpp::parse_question_timeline(object);
    CHECK(timeline.comment_id() == 4333);
    CHECK(to_seconds(timeline.creation()) == 5483104);
    CHECK(timeline.downvotes() == 10);
    CHECK(timeline.owner().name() == "user192835483");
    CHECK(timeline.post_id() == 874831);
    CHECK(timeline.question_id() == 874831);
    CHECK(timeline.revision_guid() == "5ABC480-FADBCD8");
    CHECK(timeline.type() == stackcpp::question_timeline_type::question);
    CHECK(timeline.upvotes() == 305);
    CHECK(timeline.user().name() == "aUser");
}



TEST_CASE("Questions can be parsed correctly.", "[parser][question]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "accepted_answer_id": 453840,
    "answer_count": 1,
    "answers": [{ "score": 48 }],
    "body": "I don't want to use Boost, and I can't seem to find any Standard Library way to do it. Any ideas?",
    "body_markdown": "I don't want to use [Boost](http://boost.org), and I can't seem to find any Standard Library way to do it. Any ideas?",
    "bounty_amount": 500,
    "bounty_closes_date": 2498014,
    "bounty_user": { "display_name": "HighRepUser" },
    "can_close": true,
    "can_flag": true,
    "close_vote_count": 4,
    "closed_date": 1,
    "closed_details": { "reason": "Too broad" },
    "comment_count": 1,
    "comments": [{ "body": "+1 Good question. I don't know how to do this too..." }],
    "community_owned_date": 1,
    "creation_date": 111,
    "delete_vote_count": 2,
    "down_vote_count": 5,
    "downvoted": true,
    "favorite_count": 304,
    "favorited": true,
    "is_answered": true,
    "last_activity_date": 76513,
    "last_edit_date": 4705,
    "last_editor": { "display_name": "MeMyselfAndI" },
    "link": "https://stackoverflow.com/q/9786",
    "locked_date": 140,
    "migrated_from": { "question_id": 7431 },
    "migrated_to": { "question_id": 9786 },
    "notice": { "body": "Notice, this question is controversial!" },
    "owner": { "display_name": "RocketWithEyes" },
    "protected_date": 384,
    "question_id": 9786,
    "reopen_vote_count": 1,
    "score": 2455,
    "share_link": "https://controversial.question",
    "tags": ["c++"],
    "title": "How can I join a std::vector into a std::string?",
    "up_vote_count": 246,
    "upvoted": true,
    "view_count": 4
})").HasParseError());

    const auto question = stackcpp::parse_question(object);
    CHECK(question.accepted_answer_id() == 453840);
    CHECK(question.answers().at(0).score() == 48);
    CHECK(question.content() == "I don't want to use Boost, and I can't seem to find any Standard Library way to do it. Any ideas?");
    CHECK(question.content_markdown() == "I don't want to use [Boost](http://boost.org), and I can't seem to find any Standard Library way to do it. Any ideas?");
    CHECK(question.bounty() == 500);
    CHECK(to_seconds(question.bounty_end()) == 2498014);
    CHECK(question.bounty_giver().name() == "HighRepUser");
    CHECK(question.close());
    CHECK(question.flag());
    CHECK(question.close_votes() == 4);
    CHECK(to_seconds(question.closed()) == 1);
    CHECK(question.closed_detail().reason() == "Too broad");
    CHECK(question.comments().at(0).content() == "+1 Good question. I don't know how to do this too...");
    CHECK(to_seconds(question.community_wiki()) == 1);
    CHECK(to_seconds(question.creation()) == 111);
    CHECK(question.delete_votes() == 2);
    CHECK(question.downvotes() == 5);
    CHECK(question.has_downvoted());
    CHECK(question.favorites() == 304);
    CHECK(question.has_favorited());
    CHECK(question.answered());
    CHECK(to_seconds(question.last_active()) == 76513);
    CHECK(to_seconds(question.last_edited()) == 4705);
    CHECK(question.last_editor().name() == "MeMyselfAndI");
    CHECK(question.url() == "https://stackoverflow.com/q/9786");
    CHECK(to_seconds(question.locked()) == 140);
    CHECK(question.migrated_from().question_id() == 7431);
    CHECK(question.migrated_to().question_id() == 9786);
    CHECK(question.notice().content() == "Notice, this question is controversial!");
    CHECK(question.owner().name() == "RocketWithEyes");
    CHECK(to_seconds(question.protect()) == 384);
    CHECK(question.id() == 9786);
    CHECK(question.reopen_votes() == 1);
    CHECK(question.score() == 2455);
    CHECK(question.share_url() == "https://controversial.question");
    CHECK(question.tags().at(0) == "c++");
    CHECK(question.title() == "How can I join a std::vector into a std::string?");
    CHECK(question.upvotes() == 246);
    CHECK(question.has_upvoted());
    CHECK(question.views() == 4);
}



TEST_CASE("Related sites can be parsed correctly.", "[parser][related-site]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "api_site_parameter": "testing",
    "name": "RelatedOverflow",
    "relation": "chat",
    "site_url": "https://relatedoverflow.com/chat/"
})").HasParseError());

    const auto site = stackcpp::parse_related_site(object);
    CHECK(site.api_site() == "testing");
    CHECK(site.name() == "RelatedOverflow");
    CHECK(site.relation() == "chat");
    CHECK(site.url() == "https://relatedoverflow.com/chat/");
}



TEST_CASE("Reputation histories can be parsed correctly.", "[parser][reputation-history]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "creation_date": 38,
    "post_id": 1,
    "reputation_change": 100,
    "reputation_history_type": "bounty_earned",
    "user_id": 481
})").HasParseError());

    const auto history = stackcpp::parse_reputation_history(object);
    CHECK(to_seconds(history.creation()) == 38);
    CHECK(history.post_id() == 1);
    CHECK(history.change() == 100);
    CHECK(history.type() == stackcpp::reputation_history_type::bounty_earned);
    CHECK(history.user_id() == 481);
}



TEST_CASE("Reputations can be parsed correctly.", "[parser][reputation]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "link": "https://stackoverflow.com/reputation/404",
    "on_date": 40404,
    "post_id": 440044,
    "post_type": "question",
    "reputation_change": 400,
    "title": "What does HTTP 404 mean?",
    "user_id": 40004,
    "vote_type": "bounties_won"
})").HasParseError());

    const auto reputation = stackcpp::parse_reputation(object);
    CHECK(reputation.url() == "https://stackoverflow.com/reputation/404");
    CHECK(to_seconds(reputation.time()) == 40404);
    CHECK(reputation.post_id() == 440044);
    CHECK(reputation.post_type() == stackcpp::post_type::question);
    CHECK(reputation.change() == 400);
    CHECK(reputation.title() == "What does HTTP 404 mean?");
    CHECK(reputation.user_id() == 40004);
    CHECK(reputation.vote_type() == stackcpp::vote_type::bounty_won);
}



TEST_CASE("Revisions can be parsed correctly.", "[parser][revision]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "body": "How do I do this?",
    "comment": "Fixed typos",
    "creation_date": 13840581,
    "is_rollback": true,
    "last_body": "How do i do this",
    "last_tags": ["javascript"],
    "last_title": "question about stuff",
    "post_id": 38849,
    "post_type": "question",
    "revision_guid": "AEEFC38A12D-FF24ACCD31",
    "revision_number": 1,
    "revision_type": "single_user",
    "set_community_wiki": true,
    "tags": ["javascript"],
    "title": "Question about some stuff?",
    "user": { "display_name": "1u2s3e4r5" }
})").HasParseError());

    const auto revision = stackcpp::parse_revision(object);
    CHECK(revision.content() == "How do I do this?");
    CHECK(revision.comment() == "Fixed typos");
    CHECK(to_seconds(revision.creation()) == 13840581);
    CHECK(revision.rollback());
    CHECK(revision.last_content() == "How do i do this");
    CHECK(revision.last_tags().at(0) == "javascript");
    CHECK(revision.last_title() == "question about stuff");
    CHECK(revision.post_id() == 38849);
    CHECK(revision.post_type() == stackcpp::post_type::question);
    CHECK(revision.guid() == "AEEFC38A12D-FF24ACCD31");
    CHECK(revision.index() == 1);
    CHECK(revision.type() == stackcpp::revision_type::single_user);
    CHECK(revision.community_wiki());
    CHECK(revision.tags().at(0) == "javascript");
    CHECK(revision.title() == "Question about some stuff?");
    CHECK(revision.user().name() == "1u2s3e4r5");
}



TEST_CASE("Search excerpts can be parsed correctly.", "[parser][search-excerpt]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "answer_count": 11,
    "answer_id": 120300,
    "body": "This is a search result!",
    "closed_date": 1041945,
    "community_owned_date": 1490193,
    "creation_date": 13904,
    "equivalent_tag_search": ["c++"],
    "excerpt": "Hello, World!",
    "has_accepted_answer": true,
    "is_accepted": true,
    "is_answered": true,
    "item_type": "question",
    "last_activity_date": 65830274,
    "last_activity_user": { "display_name": "shallow" },
    "locked_date": 308857,
    "owner": { "display_name": "Earth" },
    "question_id": 1380,
    "question_score": 19,
    "score": 38,
    "tags": ["c"],
    "title": "How do I write a Hello World program?"
})").HasParseError());

    const auto excerpt = stackcpp::parse_search_excerpt(object);
    CHECK(excerpt.answers() == 11);
    CHECK(excerpt.answer_id() == 120300);
    CHECK(excerpt.content() == "This is a search result!");
    CHECK(to_seconds(excerpt.closed()) == 1041945);
    CHECK(to_seconds(excerpt.community_wiki()) == 1490193);
    CHECK(to_seconds(excerpt.creation()) == 13904);
    CHECK(excerpt.equivalent_tag_search().at(0) == "c++");
    CHECK(excerpt.excerpt() == "Hello, World!");
    CHECK(excerpt.has_accepted_answer());
    CHECK(excerpt.accepted());
    CHECK(excerpt.answered());
    CHECK(excerpt.item_type() == stackcpp::post_type::question);
    CHECK(to_seconds(excerpt.last_active()) == 65830274);
    CHECK(excerpt.last_active_by().name() == "shallow");
    CHECK(to_seconds(excerpt.locked()) == 308857);
    CHECK(excerpt.owner().name() == "Earth");
    CHECK(excerpt.question_id() == 1380);
    CHECK(excerpt.question_score() == 19);
    CHECK(excerpt.score() == 38);
    CHECK(excerpt.tags().at(0) == "c");
    CHECK(excerpt.title() == "How do I write a Hello World program?");
}



TEST_CASE("Shallow users can be parsed correctly.", "[parser][shallow-user") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "accept_rate": 45,
    "badge_counts": { "bronze": 401 },
    "display_name": "someone",
    "link": "https://stackoverflow.com/184014/someone",
    "profile_image": "https://image.so/someone",
    "reputation": 310670,
    "user_id": 184014,
    "user_type": "moderator"
})").HasParseError());

    const auto user = stackcpp::parse_shallow_user(object);
    CHECK(user.accept_rate() == 45);
    CHECK(user.badges().bronze() == 401);
    CHECK(user.name() == "someone");
    CHECK(user.url() == "https://stackoverflow.com/184014/someone");
    CHECK(user.avatar() == "https://image.so/someone");
    CHECK(user.reputation() == 310670);
    CHECK(user.id() == 184014);
    CHECK(user.type() == stackcpp::user_type::moderator);
}



TEST_CASE("Sites can be parsed correctly.", "[parser][site]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "aliases": ["secret"],
    "api_site_parameter": "dksfjl",
    "audience": "very secret agents",
    "closed_beta_date": 1,
    "favicon_url": "https://secret.onion/fav",
    "high_resolution_icon_url": "https://secret.onion/icon_high",
    "icon_url": "https://secret.onion/icon",
    "launch_date": 1,
    "logo_url": "https://secret.onion/logo",
    "markdown_extensions": ["passwordy"],
    "name": "Secret SE",
    "open_beta_date": 1,
    "related_sites": [{ "name": "secret-agents" }],
    "site_state": "normal",
    "site_type": "main_site",
    "site_url": "https://dksfjl.stackexchange.com/",
    "styling": { "link_color": "black" },
    "twitter_account": "@dksfjl"
})").HasParseError());

    const auto site = stackcpp::parse_site(object);
    CHECK(site.aliases().at(0) == "secret");
    CHECK(site.api_site() == "dksfjl");
    CHECK(site.audience() == "very secret agents");
    CHECK(to_seconds(site.beta_closed()) == 1);
    CHECK(site.favicon() == "https://secret.onion/fav");
    CHECK(site.icon_high_res() == "https://secret.onion/icon_high");
    CHECK(site.icon() == "https://secret.onion/icon");
    CHECK(to_seconds(site.launch()) == 1);
    CHECK(site.logo() == "https://secret.onion/logo");
    CHECK(site.markdown_extensions().at(0) == "passwordy");
    CHECK(site.name() == "Secret SE");
    CHECK(to_seconds(site.open_beta()) == 1);
    CHECK(site.related().at(0).name() == "secret-agents");
    CHECK(site.state() == stackcpp::site_state::normal);
    CHECK(site.type() == "main_site");
    CHECK(site.url() == "https://dksfjl.stackexchange.com/");
    CHECK(site.style().link_color() == "black");
    CHECK(site.twitter() == "@dksfjl");
}



TEST_CASE("Stylings can be parsed correctly.", "[parser][styling]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "link_color": "#rainbow",
    "tag_background_color": "#BEEF",
    "tag_foreground_color": "#C0FFEE"
})").HasParseError());

    const auto style = stackcpp::parse_styling(object);
    CHECK(style.link_color() == "#rainbow");
    CHECK(style.tag_background_color() == "#BEEF");
    CHECK(style.tag_foreground_color() == "#C0FFEE");
}



TEST_CASE("Suggested edits can be parsed correctly.", "[parser][suggested-edit]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "approval_date": 8947141,
    "body": "HAHAHAHA TROLOLOLOLO",
    "comment": "Improved post.",
    "creation_date": 180483,
    "post_id": 4888851,
    "post_type": "answer",
    "proposing_user": { "display_name": "NotATroll" },
    "rejection_date": 5738933,
    "suggested_edit_id": 3810,
    "tags": ["math"],
    "title": "Proof of 1+1=window"
})").HasParseError());

    const auto edit = stackcpp::parse_suggested_edit(object);
    CHECK(to_seconds(edit.approval()) == 8947141);
    CHECK(edit.content() == "HAHAHAHA TROLOLOLOLO");
    CHECK(to_seconds(edit.creation()) == 180483);
    CHECK(edit.post_id() == 4888851);
    CHECK(edit.post_type() == stackcpp::post_type::answer);
    CHECK(edit.proposer().name() == "NotATroll");
    CHECK(to_seconds(edit.rejection()) == 5738933);
    CHECK(edit.id() == 3810);
    CHECK(edit.tags().at(0) == "math");
    CHECK(edit.title() == "Proof of 1+1=window");
}



TEST_CASE("Tag scores can be parsed correctly.", "[parser][tag-score]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "post_count": 14,
    "score": 3801,
    "user": { "display_name": "ILikeStackOverflow" }
})").HasParseError());

    const auto score = stackcpp::parse_tag_score(object);
    CHECK(score.amount() == 14);
    CHECK(score.score() == 3801);
    CHECK(score.user().name() == "ILikeStackOverflow");
}



TEST_CASE("Tag synonyms can be parsed correctly.", "[parser][tag-synonym]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "applied_count": 384014,
    "creation_date": 85747154,
    "from_tag": "cplusplus",
    "last_applied_date": 18205305,
    "to_tag": "c++"
})").HasParseError());

    const auto synonym = stackcpp::parse_tag_synonym(object);
    CHECK(synonym.applied() == 384014);
    CHECK(to_seconds(synonym.creation()) == 85747154);
    CHECK(synonym.from() == "cplusplus");
    CHECK(to_seconds(synonym.last_applied()) == 18205305);
    CHECK(synonym.to() == "c++");
}



TEST_CASE("Tag wikis can be parsed correctly.", "[parser][tag-wiki]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "body": "C++ is the best language in the world!",
    "body_last_edit_date": 13095731,
    "excerpt": "C++ is a programming language.",
    "excerpt_last_edit_date": 480131,
    "last_body_editor": { "display_name": "cpplover" },
    "last_excerpt_editor": { "display_name": "machineAI" },
    "tag_name": "c++"
})").HasParseError());

    const auto wiki = stackcpp::parse_tag_wiki(object);
    CHECK(wiki.content() == "C++ is the best language in the world!");
    CHECK(to_seconds(wiki.last_content_edit()) == 13095731);
    CHECK(wiki.excerpt() == "C++ is a programming language.");
    CHECK(to_seconds(wiki.last_excerpt_edit()) == 480131);
    CHECK(wiki.last_content_editor().name() == "cpplover");
    CHECK(wiki.last_excerpt_editor().name() == "machineAI");
    CHECK(wiki.name() == "c++");
}



TEST_CASE("Tags can be parsed correctly.", "[parser][tag]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "count": 10348,
    "has_synonyms": true,
    "is_moderator_only": true,
    "is_required": true,
    "last_activity_date": 10385710,
    "name": "generic",
    "synonyms": ["tag"],
    "user_id": 1380984
})").HasParseError());

    const auto tag = stackcpp::parse_tag(object);
    CHECK(tag.count() == 10348);
    CHECK(tag.has_synonyms());
    CHECK(tag.moderator_only());
    CHECK(tag.required());
    CHECK(to_seconds(tag.last_active()) == 10385710);
    CHECK(tag.name() == "generic");
    CHECK(tag.synonyms().at(0) == "tag");
    CHECK(tag.user_id() == 1380984);
}



TEST_CASE("Top tags can be parsed correctly.", "[parser][top-tag]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "answer_count": 483885,
    "answer_score": 36489580,
    "question_count": 3856,
    "question_score": 138057,
    "tag_name": "sorting",
    "user_id": 397513
})").HasParseError());

    const auto tag = stackcpp::parse_top_tag(object);
    CHECK(tag.answers() == 483885);
    CHECK(tag.answer_score() == 36489580);
    CHECK(tag.questions() == 3856);
    CHECK(tag.question_score() == 138057);
    CHECK(tag.name() == "sorting");
    CHECK(tag.user_id() == 397513);
}



TEST_CASE("User timelines can be parsed correctly.", "[parser][user-timeline]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "badge_id": 3180,
    "comment_id": 8573,
    "creation_date": 13085803,
    "detail": "Some random details...",
    "link": "https://stackoverflow.com/users/timeline",
    "post_id": 5701,
    "suggested_edit_id": 1038,
    "timeline_type": "commented",
    "title": "Hi! I'm a title!",
    "user_id": 4831
})").HasParseError());

    const auto timeline = stackcpp::parse_user_timeline(object);
    CHECK(timeline.badge_id() == 3180);
    CHECK(timeline.comment_id() == 8573);
    CHECK(to_seconds(timeline.creation()) == 13085803);
    CHECK(timeline.detail() == "Some random details...");
    CHECK(timeline.url() == "https://stackoverflow.com/users/timeline");
    CHECK(timeline.post_id() == 5701);
    CHECK(timeline.suggested_edit_id() == 1038);
    CHECK(timeline.type() == stackcpp::user_timeline_type::commented);
    CHECK(timeline.title() == "Hi! I'm a title!");
    CHECK(timeline.user_id() == 4831);
}



TEST_CASE("Users can be parsed correctly.", "[parser][user]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "about_me": "My about me is blank... :(",
    "accept_rate": 1,
    "account_id": 380418,
    "age": 294,
    "answer_count": 39,
    "badge_counts": { "bronze": 20 },
    "creation_date": 137957,
    "display_name": "OldHuman",
    "down_vote_count": 5,
    "is_employee": true,
    "last_access_date": 3085731,
    "last_modified_date": 1901830,
    "link": "https://stackoverflow.com/users/145793/OldHuman",
    "location": "Earth",
    "profile_image": "https://nasa.gov/earth",
    "question_count": 385,
    "reputation": 8508,
    "reputation_change_day": 40,
    "reputation_change_month": 230,
    "reputation_change_quarter": 313,
    "reputation_change_week": 90,
    "reputation_change_year": 874,
    "timed_penalty_date": 5637294,
    "up_vote_count": 840,
    "user_id": 145793,
    "view_count": 304,
    "website_url": "https://earth.com"
})").HasParseError());

    const auto user = stackcpp::parse_user(object);
    CHECK(user.about_me() == "My about me is blank... :(");
    CHECK(user.accept_rate() == 1);
    CHECK(user.account_id() == 380418);
    CHECK(user.age() == 294);
    CHECK(user.answers() == 39);
    CHECK(user.badges().bronze() == 20);
    CHECK(to_seconds(user.creation()) == 137957);
    CHECK(user.name() == "OldHuman");
    CHECK(user.downvotes() == 5);
    CHECK(user.employee());
    CHECK(to_seconds(user.last_accessed()) == 3085731);
    CHECK(to_seconds(user.last_modified()) == 1901830);
    CHECK(user.profile() == "https://stackoverflow.com/users/145793/OldHuman");
    CHECK(user.location() == "Earth");
    CHECK(user.avatar() == "https://nasa.gov/earth");
    CHECK(user.questions() == 385);
    CHECK(user.reputation() == 8508);
    CHECK(user.reputation_day() == 40);
    CHECK(user.reputation_month() == 230);
    CHECK(user.reputation_quarter() == 313);
    CHECK(user.reputation_week() == 90);
    CHECK(user.reputation_year() == 874);
    CHECK(to_seconds(user.suspension()) == 5637294);
    CHECK(user.upvotes() == 840);
    CHECK(user.id() == 145793);
    CHECK(user.profile_views() == 304);
    CHECK(user.personal_site() == "https://earth.com");
}



TEST_CASE("Parsing types from JSON.", "[parser][type]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "pinteger": 3804,
    "ninteger": -483,
    "string": "Hello World!",
    "date": 3019805,
    "decimal": 304.31,
    "bool": true,
    "id": 308193,
    "array": [13, 5, 24, 580]
})").HasParseError());

    SECTION("Integers are parsed correctly (or not).") {
        CHECK(stackcpp::parse_integer(object["pinteger"]) == 3804);
        CHECK(stackcpp::parse_integer(object["ninteger"]) == -483);
        CHECK_THROWS_AS(stackcpp::parse_integer(object["string"]), stackcpp::invalid_json_value);
    }

    SECTION("Strings are parsed correctly (or not).") {
        CHECK(stackcpp::parse_string(object["string"]) == "Hello World!");
        CHECK_THROWS_AS(stackcpp::parse_string(object["date"]), stackcpp::invalid_json_value);
    }

    SECTION("Dates are parsed correctly (or not).") {
        CHECK(to_seconds(stackcpp::parse_date(object["date"])) == 3019805);
        CHECK_THROWS_AS(stackcpp::parse_date(object["decimal"]), stackcpp::invalid_json_value);
    }

    SECTION("Decimals are parsed correctly (or not).") {
        CHECK(stackcpp::parse_decimal(object["decimal"]) == Approx(304.31));
        CHECK_THROWS_AS(stackcpp::parse_decimal(object["bool"]), stackcpp::invalid_json_value);
    }

    SECTION("Booleans are parsed correctly (or not).") {
        CHECK(stackcpp::parse_bool(object["bool"]));
        CHECK_THROWS_AS(stackcpp::parse_bool(object["id"]), stackcpp::invalid_json_value);
    }

    SECTION("Unique ids are parsed correctly (or not).") {
        CHECK(stackcpp::parse_unique_id(object["id"]) == 308193);
        CHECK_THROWS_AS(stackcpp::parse_unique_id(object["array"]), stackcpp::invalid_json_value);
    }

    SECTION("Arrays are parsed correctly (or not).") {
        const auto array = stackcpp::parse_array(object["array"], &stackcpp::parse_integer);

        CHECK(array.at(0) == 13);
        CHECK(array.at(1) == 5);
        CHECK(array.at(2) == 24);
        CHECK(array.at(3) == 580);
        CHECK_THROWS_AS(stackcpp::parse_array(object["pinteger"], &stackcpp::parse_integer), stackcpp::invalid_json_value);
    }
}



TEST_CASE("Field are parsed and updated correctly.", "[parser][field]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "value": "hello json"
})").HasParseError());

    std::string value;
    CHECK_NOTHROW(stackcpp::update_field(value, object, "value", &stackcpp::parse_string));
    CHECK(value == "hello json");
}



TEST_CASE("Enumerations are parsed correctly.", "[parser][enumeration]") {
    REQUIRE_FALSE(object.Parse(R"(
{
    "error": "don't error me!",
    "user_types": ["unregistered", "registered", "moderator", "does_not_exist"],
    "post_types": ["question", "answer"],
    "badge_types": ["named", "tag_based"],
    "badge_ranks": ["bronze", "silver", "gold"],
    "site_states": ["normal", "closed_beta", "open_beta", "linked_meta"],
    "activity_types": ["question_posted", "answer_posted", "badge_earned", "comment_posted"],
    "vote_types": ["accepts", "up_votes", "down_votes", "bounties_offered", "bounties_won", "spam", "suggested_edits"],
    "notification_types": ["generic", "profile_activity", "bounty_expired", "bounty_expires_in_one_day", "badge_earned", "bounty_expires_in_three_days",
                           "reputation_bonus", "accounts_associated", "new_privilege", "post_migrated", "moderator_message", "registration_reminder",
                           "edit_suggested", "substantive_edit", "bounty_grace_period_started"],
    "reputation_history_types": ["asker_accepts_answer", "asker_unaccept_answer", "answer_accepted", "answer_unaccepted", "voter_downvotes", "voter_undownvotes",
                                 "post_downvoted", "post_undownvoted", "post_upvoted", "post_unupvoted", "suggested_edit_approval_received", "post_flagged_as_spam",
                                 "post_flagged_as_offensive", "bounty_given", "bounty_earned", "bounty_cancelled", "post_deleted", "post_undeleted", "association_bonus",
                                 "arbitrary_reputation_change", "vote_fraud_reversal", "post_migrated", "user_deleted", "example_upvoted", "example_unupvoted",
                                 "proposed_change_approved", "doc_link_upvoted", "doc_link_unupvoted", "doc_source_removed", "suggested_edit_approval_overridden"],
    "user_timeline_types": ["commented", "asked", "answered", "badge", "revision", "accepted", "reviewed", "suggested"],
    "item_types": ["comment", "chat_message", "new_answer", "careers_message", "careers_invitations", "meta_question", "post_notice", "moderator_message"],
    "event_types": ["question_posted", "answer_posted", "comment_posted", "post_edited", "user_created"],
    "revision_types": ["single_user", "vote_based"],
    "question_timeline_types": ["question", "answer", "comment", "unaccepted_answer", "accepted_answer", "vote_aggregate", "revision", "post_state_changed"]
})").HasParseError());

    SECTION("User types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["user_types"], &stackcpp::parse_user_type);

        CHECK(types.at(0) == stackcpp::user_type::unregistered);
        CHECK(types.at(1) == stackcpp::user_type::registered);
        CHECK(types.at(2) == stackcpp::user_type::moderator);
        CHECK(types.at(3) == stackcpp::user_type::does_not_exist);
        CHECK_THROWS_AS(stackcpp::parse_user_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Post types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["post_types"], &stackcpp::parse_post_type);

        CHECK(types.at(0) == stackcpp::post_type::question);
        CHECK(types.at(1) == stackcpp::post_type::answer);
        CHECK_THROWS_AS(stackcpp::parse_post_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Badge types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["badge_types"], &stackcpp::parse_badge_type);

        CHECK(types.at(0) == stackcpp::badge_type::named);
        CHECK(types.at(1) == stackcpp::badge_type::tag_based);
        CHECK_THROWS_AS(stackcpp::parse_badge_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Badge ranks are parsed correctly (or not).") {
        const auto ranks = stackcpp::parse_array(object["badge_ranks"], &stackcpp::parse_badge_rank);

        CHECK(ranks.at(0) == stackcpp::badge_rank::bronze);
        CHECK(ranks.at(1) == stackcpp::badge_rank::silver);
        CHECK(ranks.at(2) == stackcpp::badge_rank::gold);
        CHECK_THROWS_AS(stackcpp::parse_badge_rank(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Site states are parsed correctly (or not).") {
        const auto states = stackcpp::parse_array(object["site_states"], &stackcpp::parse_site_state);

        CHECK(states.at(0) == stackcpp::site_state::normal);
        CHECK(states.at(1) == stackcpp::site_state::closed_beta);
        CHECK(states.at(2) == stackcpp::site_state::open_beta);
        CHECK(states.at(3) == stackcpp::site_state::linked_meta);
        CHECK_THROWS_AS(stackcpp::parse_site_state(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Activity types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["activity_types"], &stackcpp::parse_activity_type);

        CHECK(types.at(0) == stackcpp::activity_type::question_posted);
        CHECK(types.at(1) == stackcpp::activity_type::answer_posted);
        CHECK(types.at(2) == stackcpp::activity_type::badge_earned);
        CHECK(types.at(3) == stackcpp::activity_type::comment_posted);
        CHECK_THROWS_AS(stackcpp::parse_activity_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Vote types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["vote_types"], &stackcpp::parse_vote_type);

        CHECK(types.at(0) == stackcpp::vote_type::accept);
        CHECK(types.at(1) == stackcpp::vote_type::upvote);
        CHECK(types.at(2) == stackcpp::vote_type::downvote);
        CHECK(types.at(3) == stackcpp::vote_type::bounty_offered);
        CHECK(types.at(4) == stackcpp::vote_type::bounty_won);
        CHECK(types.at(5) == stackcpp::vote_type::spam);
        CHECK(types.at(6) == stackcpp::vote_type::suggested_edit);
        CHECK_THROWS_AS(stackcpp::parse_vote_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Notification types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["notification_types"], &stackcpp::parse_notification_type);

        CHECK(types.at(0) == stackcpp::notification_type::generic);
        CHECK(types.at(1) == stackcpp::notification_type::profile_activity);
        CHECK(types.at(2) == stackcpp::notification_type::bounty_expired);
        CHECK(types.at(3) == stackcpp::notification_type::bounty_expires_in_one_day);
        CHECK(types.at(4) == stackcpp::notification_type::badge_earned);
        CHECK(types.at(5) == stackcpp::notification_type::bounty_expires_in_three_days);
        CHECK(types.at(6) == stackcpp::notification_type::reputation_bonus);
        CHECK(types.at(7) == stackcpp::notification_type::accounts_associated);
        CHECK(types.at(8) == stackcpp::notification_type::new_privilege);
        CHECK(types.at(9) == stackcpp::notification_type::post_migrated);
        CHECK(types.at(10) == stackcpp::notification_type::moderator_message);
        CHECK(types.at(11) == stackcpp::notification_type::registration_reminder);
        CHECK(types.at(12) == stackcpp::notification_type::edit_suggested);
        CHECK(types.at(13) == stackcpp::notification_type::substantive_edit);
        CHECK(types.at(14) == stackcpp::notification_type::bounty_grace_period_started);
        CHECK_THROWS_AS(stackcpp::parse_notification_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Reputation history types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["reputation_history_types"], &stackcpp::parse_reputation_history_type);

        CHECK(types.at(0) == stackcpp::reputation_history_type::asker_accepts_answer);
        CHECK(types.at(1) == stackcpp::reputation_history_type::asker_unaccepts_answer);
        CHECK(types.at(2) == stackcpp::reputation_history_type::answer_accepted);
        CHECK(types.at(3) == stackcpp::reputation_history_type::answer_unaccepted);
        CHECK(types.at(4) == stackcpp::reputation_history_type::voter_downvotes);
        CHECK(types.at(5) == stackcpp::reputation_history_type::voter_undownvotes);
        CHECK(types.at(6) == stackcpp::reputation_history_type::post_downvoted);
        CHECK(types.at(7) == stackcpp::reputation_history_type::post_undownvoted);
        CHECK(types.at(8) == stackcpp::reputation_history_type::post_upvoted);
        CHECK(types.at(9) == stackcpp::reputation_history_type::post_unupvoted);
        CHECK(types.at(10) == stackcpp::reputation_history_type::suggested_edit_approved);
        CHECK(types.at(11) == stackcpp::reputation_history_type::post_flagged_as_spam);
        CHECK(types.at(12) == stackcpp::reputation_history_type::post_flagged_as_offensive);
        CHECK(types.at(13) == stackcpp::reputation_history_type::bounty_given);
        CHECK(types.at(14) == stackcpp::reputation_history_type::bounty_earned);
        CHECK(types.at(15) == stackcpp::reputation_history_type::bounty_cancelled);
        CHECK(types.at(16) == stackcpp::reputation_history_type::post_deleted);
        CHECK(types.at(17) == stackcpp::reputation_history_type::post_undeleted);
        CHECK(types.at(18) == stackcpp::reputation_history_type::association_bonus);
        CHECK(types.at(19) == stackcpp::reputation_history_type::arbitrary_reputation_change);
        CHECK(types.at(20) == stackcpp::reputation_history_type::vote_fraud_reversal);
        CHECK(types.at(21) == stackcpp::reputation_history_type::post_migrated);
        CHECK(types.at(22) == stackcpp::reputation_history_type::user_deleted);
        CHECK(types.at(23) == stackcpp::reputation_history_type::example_upvoted);
        CHECK(types.at(24) == stackcpp::reputation_history_type::example_unupvoted);
        CHECK(types.at(25) == stackcpp::reputation_history_type::proposed_change_approved);
        CHECK(types.at(26) == stackcpp::reputation_history_type::doc_link_upvoted);
        CHECK(types.at(27) == stackcpp::reputation_history_type::doc_link_unupvoted);
        CHECK(types.at(28) == stackcpp::reputation_history_type::doc_source_removed);
        CHECK(types.at(29) == stackcpp::reputation_history_type::suggested_edit_approval_overridden);
        CHECK_THROWS_AS(stackcpp::parse_reputation_history_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("User timeline types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["user_timeline_types"], &stackcpp::parse_user_timeline_type);

        CHECK(types.at(0) == stackcpp::user_timeline_type::commented);
        CHECK(types.at(1) == stackcpp::user_timeline_type::asked);
        CHECK(types.at(2) == stackcpp::user_timeline_type::answered);
        CHECK(types.at(3) == stackcpp::user_timeline_type::badge);
        CHECK(types.at(4) == stackcpp::user_timeline_type::revision);
        CHECK(types.at(5) == stackcpp::user_timeline_type::accepted);
        CHECK(types.at(6) == stackcpp::user_timeline_type::reviewed);
        CHECK(types.at(7) == stackcpp::user_timeline_type::suggested);
        CHECK_THROWS_AS(stackcpp::parse_user_timeline_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Item types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["item_types"], &stackcpp::parse_item_type);

        CHECK(types.at(0) == stackcpp::item_type::comment);
        CHECK(types.at(1) == stackcpp::item_type::chat_message);
        CHECK(types.at(2) == stackcpp::item_type::new_answer);
        CHECK(types.at(3) == stackcpp::item_type::careers_message);
        CHECK(types.at(4) == stackcpp::item_type::careers_invitations);
        CHECK(types.at(5) == stackcpp::item_type::meta_question);
        CHECK(types.at(6) == stackcpp::item_type::post_notice);
        CHECK(types.at(7) == stackcpp::item_type::moderator_message);
        CHECK_THROWS_AS(stackcpp::parse_item_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Event types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["event_types"], &stackcpp::parse_event_type);

        CHECK(types.at(0) == stackcpp::event_type::question_posted);
        CHECK(types.at(1) == stackcpp::event_type::answer_posted);
        CHECK(types.at(2) == stackcpp::event_type::comment_posted);
        CHECK(types.at(3) == stackcpp::event_type::post_edited);
        CHECK(types.at(4) == stackcpp::event_type::user_created);
        CHECK_THROWS_AS(stackcpp::parse_event_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Revision types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["revision_types"], &stackcpp::parse_revision_type);

        CHECK(types.at(0) == stackcpp::revision_type::single_user);
        CHECK(types.at(1) == stackcpp::revision_type::vote_based);
        CHECK_THROWS_AS(stackcpp::parse_revision_type(object["error"]), stackcpp::unknown_enum_string);
    }

    SECTION("Question timeline types are parsed correctly (or not).") {
        const auto types = stackcpp::parse_array(object["question_timeline_types"], &stackcpp::parse_question_timeline_type);

        CHECK(types.at(0) == stackcpp::question_timeline_type::question);
        CHECK(types.at(1) == stackcpp::question_timeline_type::answer);
        CHECK(types.at(2) == stackcpp::question_timeline_type::comment);
        CHECK(types.at(3) == stackcpp::question_timeline_type::unaccepted_answer);
        CHECK(types.at(4) == stackcpp::question_timeline_type::accepted_answer);
        CHECK(types.at(5) == stackcpp::question_timeline_type::vote_aggregate);
        CHECK(types.at(6) == stackcpp::question_timeline_type::revision);
        CHECK(types.at(7) == stackcpp::question_timeline_type::post_state_changed);
        CHECK_THROWS_AS(stackcpp::parse_question_timeline_type(object["error"]), stackcpp::unknown_enum_string);
    }
}



TEST_CASE("Restrictions can be applied.", "[restriction]") {
    // Types of restrictions are grouped by sections, so don't panic if you don't see a restriction being tested,
    // it is probably already covered by another restriction of the same group.
    SECTION("Basic restrictions can be applied.") {
        stackcpp::user_restrict restriction = stackcpp::user_sort::reputation | stackcpp::filter("hello");
        restriction |= stackcpp::unsafe() | stackcpp::min(10) | stackcpp::max(5) | stackcpp::ascending();
        restriction |= stackcpp::from_date(std::chrono::system_clock::from_time_t(5472924));
        restriction |= stackcpp::to_date(std::chrono::system_clock::from_time_t(4717533));

        const auto map = restriction.as_map();
        CHECK(map.at("sort") == "reputation");
        CHECK(map.at("filter") == "hello");
        CHECK(map.at("min") == "10");
        CHECK(map.at("max") == "5");
        CHECK(map.at("order") == "asc");
        CHECK(map.at("fromdate") == "5472924");
        CHECK(map.at("todate") == "4717533");
    }

    SECTION("Advanced search restrictions can be applied.") {
        stackcpp::search_restrict restriction = stackcpp::search_sort::score | stackcpp::search("what is std::void_t?");
        restriction |= stackcpp::filter("c++") | stackcpp::unsafe() | stackcpp::accepted(true);
        restriction |= stackcpp::answers(1) | stackcpp::body("std::void_t") | stackcpp::closed(true);
        restriction |= stackcpp::migrated(true) | stackcpp::nottagged("c") | stackcpp::tagged("c++17");
        restriction |= stackcpp::title("std::void_t") | stackcpp::owner(4619837_uid) | stackcpp::url("https://google.com/*");
        restriction |= stackcpp::views(100) | stackcpp::wiki(true) | stackcpp::information(true);

        const auto map = restriction.as_map();
        CHECK(map.at("sort") == "votes");
        CHECK(map.at("filter") == "c++");
        CHECK(map.at("q") == "what is std::void_t?");
        CHECK(map.at("accepted") == "true");
        CHECK(map.at("answers") == "1");
        CHECK(map.at("body") == "std::void_t");
        CHECK(map.at("closed") == "true");
        CHECK(map.at("migrated") == "true");
        CHECK(map.at("nottagged") == "c");
        CHECK(map.at("tagged") == "c++17");
        CHECK(map.at("title") == "std::void_t");
        CHECK(map.at("user") == "4619837");
        CHECK(map.at("url") == "https://google.com/*");
        CHECK(map.at("views") == "100");
        CHECK(map.at("wiki") == "true");
        CHECK(map.at("notice") == "true");
    }
}



TEST_CASE("Values are parsed correctly.", "[parser][value]") {
    CHECK(stackcpp::parse_value(stackcpp::integer_t{3910}) == "3910");
    CHECK(stackcpp::parse_value(stackcpp::uinteger_t{184}) == "184");
    CHECK(stackcpp::parse_value(std::string{"hello"}) == "hello");
    CHECK(stackcpp::parse_value(std::chrono::system_clock::from_time_t(56)) == "56");
    CHECK(stackcpp::parse_value(true) == "true");
    CHECK(stackcpp::parse_value(stackcpp::badge_rank::silver) == "silver");
    CHECK(stackcpp::parse_value(stackcpp::period::all_time) == "all_time");
    CHECK(stackcpp::parse_value(stackcpp::site_type::meta) == "meta_site");
    CHECK(stackcpp::parse_value(stackcpp::site_type::main | stackcpp::site_type::meta) == "main_site;meta_site");
}
