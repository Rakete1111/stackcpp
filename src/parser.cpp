// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.



#include "stackcpp/parser.h"

#include "stackcpp/helpers/parser-impl.hpp"
#include "stackcpp/misc/exceptions.h"

#include <rapidjson/document.h>
#include <utility>



namespace stackcpp {

std::string parse_enum(const user_sort& sort) {
    switch (sort) {
    case user_sort::reputation:
        return "reputation";
    case user_sort::creation_date:
        return "creation";
    case user_sort::display_name:
        return "name";
    case user_sort::modified_date:
        return "modified";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const answer_sort& sort) {
    switch (sort) {
    case answer_sort::activity:
        return "activity";
    case answer_sort::creation_date:
        return "creation";
    case answer_sort::votes:
        return "votes";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const badge_sort& sort) {
    switch (sort) {
    case badge_sort::rank:
        return "rank";
    case badge_sort::name:
        return "name";
    case badge_sort::type:
        return "type";
    case badge_sort::awarded_date:
        return "awarded";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const comment_sort& sort) {
    switch (sort) {
    case comment_sort::creation_date:
        return "creation";
    case comment_sort::votes:
        return "votes";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const favorite_sort& sort) {
    switch (sort) {
    case favorite_sort::last_activity:
        return "activity";
    case favorite_sort::creation_date:
        return "creation";
    case favorite_sort::votes:
        return "votes";
    case favorite_sort::added:
        return "added";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const activity_sort& sort) noexcept {
    std::string result;
    if ((sort & activity_sort::post) != 0)
        result += "posts;";
    if ((sort & activity_sort::badge) != 0)
        result += "badges;";
    if ((sort & activity_sort::comment) != 0)
        result += "comments;";

    if (!result.empty())
        result.pop_back();
    return result;
}



std::string parse_enum(const post_sort& sort) {
    switch (sort) {
    case post_sort::activity:
        return "activity";
    case post_sort::creation:
        return "creation";
    case post_sort::score:
        return "votes";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const question_sort& sort) {
    switch (sort) {
    case question_sort::activity:
        return "activity";
    case question_sort::creation:
        return "creation";
    case question_sort::score:
        return "votes";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const suggested_edit_sort& sort) {
    switch (sort) {
    case suggested_edit_sort::creation:
        return "creation";
    case suggested_edit_sort::approval:
        return "approval";
    case suggested_edit_sort::rejection:
        return "rejection";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const tag_sort& sort) {
    switch (sort) {
    case tag_sort::count:
        return "popular";
    case tag_sort::activity:
        return "activity";
    case tag_sort::name:
        return "name";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const search_sort& sort) {
    switch (sort) {
    case search_sort::activity:
        return "activity";
    case search_sort::creation:
        return "creation";
    case search_sort::score:
        return "votes";
    case search_sort::relevance:
        return "relevance";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const synonym_sort& sort) {
    switch (sort) {
    case synonym_sort::creation:
        return "creation";
    case synonym_sort::applied_count:
        return "applied";
    case synonym_sort::activity:
        return "activity";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const query_order& order) {
    switch (order) {
    case query_order::descending:
        return "desc";
    case query_order::ascending:
        return "asc";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_enum(const badge_rank& rank) {
    switch (rank) {
    case badge_rank::bronze:
        return "bronze";
    case badge_rank::silver:
        return "silver";
    case badge_rank::gold:
        return "gold";
    default:
        throw enum_missing_string{};
    }
}



std::string parse_value(const integer_t value) noexcept {
    return std::to_string(value);
}



std::string parse_value(const uinteger_t value) noexcept {
    return std::to_string(value);
}



std::string parse_value(const date_t value) noexcept {
    return std::to_string(std::chrono::duration_cast<std::chrono::seconds>(value.time_since_epoch()).count());
}



std::string parse_value(const bool value) noexcept {
    return value ? "true" : "false";
}



std::string parse_value(const std::string& value) noexcept {
    return value;
}



std::string parse_value(const badge_rank& value) noexcept {
    return parse_enum(value);
}



std::string parse_value(const period& value) {
    if (value == period::all_time)
        return "all_time";
    if (value == period::month)
        return "month";
    throw enum_missing_string{};
}



std::string parse_value(const site_type& value) {
    std::string string;
    if ((value & site_type::main) != 0)
        string += "main_site;";
    if ((value & site_type::meta) != 0)
        string += "meta_site;";

    if (!string.empty())
        string.pop_back();
    return string;
}



user parse_user(const rapidjson::Value& properties) {
    user human;
    update_field(human.name_, properties, "display_name", &parse_string);
    update_field(human.account_id_, properties, "account_id", &parse_unique_id);
    update_field(human.badges_, properties, "badge_counts", &parse_badge_count);
    update_field(human.creation_, properties, "creation_date", &parse_date);
    update_field(human.employee_, properties, "is_employee", &parse_bool);
    update_field(human.last_accessed_, properties, "last_access_date", &parse_date);
    update_field(human.profile_, properties, "link", &parse_string);
    update_field(human.avatar_, properties, "profile_image", &parse_string);
    update_field(human.reputation_, properties, "reputation", &parse_integer);
    update_field(human.reputation_day_, properties, "reputation_change_day", &parse_integer);
    update_field(human.reputation_week_, properties, "reputation_change_week", &parse_integer);
    update_field(human.reputation_month_, properties, "reputation_change_month", &parse_integer);
    update_field(human.reputation_quarter_, properties, "reputation_change_quarter", &parse_integer);
    update_field(human.reputation_year_, properties, "reputation_change_year", &parse_integer);
    update_field(human.id_, properties, "user_id", &parse_unique_id);
    update_field(human.type_, properties, "user_type", &parse_user_type);
    update_field(human.accept_rate_, properties, "accept_rate", &parse_integer);
    update_field(human.age_, properties, "age", &parse_integer);
    update_field(human.last_modified_, properties, "last_modified_date", &parse_date);
    update_field(human.location_, properties, "location", &parse_string);
    update_field(human.suspension_, properties, "timed_penalty_date", &parse_date);
    update_field(human.personal_site_, properties, "website_url", &parse_string);
    update_field(human.answers_, properties, "answer_count", &parse_integer);
    update_field(human.downvotes_, properties, "down_vote_count", &parse_integer);
    update_field(human.questions_, properties, "question_count", &parse_integer);
    update_field(human.upvotes_, properties, "up_vote_count", &parse_integer);
    update_field(human.profile_views_, properties, "view_count", &parse_integer);
    update_field(human.about_me_, properties, "about_me", &parse_string);
    return human;
}



answer parse_answer(const rapidjson::Value& properties) {
    answer post;
    update_field(post.has_accepted_, properties, "accepted", &parse_bool);
    update_field(post.id_, properties, "answer_id", &parse_unique_id);
    update_field(post.content_, properties, "body", &parse_string);
    update_field(post.content_markdown_, properties, "body_markdown", &parse_string);
    update_field(post.flag_, properties, "can_flag", &parse_bool);
    update_field(post.creation_, properties, "creation_date", &parse_date);
    update_field(post.accepted_, properties, "is_accepted", &parse_bool);
    update_field(post.last_active_, properties, "last_activity_date", &parse_date);
    update_field(post.question_id_, properties, "question_id", &parse_unique_id);
    update_field(post.score_, properties, "score", &parse_integer);
    update_field(post.community_wiki_, properties, "community_owned_date", &parse_date);
    update_field(post.last_edited_, properties, "last_edit_date", &parse_date);
    update_field(post.locked_, properties, "locked_date", &parse_date);
    update_field(post.owner_, properties, "owner", &parse_shallow_user);
    update_field(post.content_, properties, "body", &parse_string);
    update_field(post.content_markdown_, properties, "body_markdown", &parse_string);
    update_field(post.flag_, properties, "can_flag", &parse_bool);
    update_field(post.downvotes_, properties, "down_vote_count", &parse_integer);
    update_field(post.has_downvoted_, properties, "downvoted", &parse_bool);
    update_field(post.last_editor_, properties, "last_editor", &parse_shallow_user);
    update_field(post.url_, properties, "link", &parse_string);
    update_field(post.share_url_, properties, "share_link", &parse_string);
    update_field(post.tags_, properties, "tags", &parse_array<std::string>, &parse_string);
    update_field(post.title_, properties, "title", &parse_string);
    update_field(post.upvotes_, properties, "up_vote_count", &parse_integer);
    update_field(post.bounty_, properties, "awarded_bounty_amount", &parse_integer);
    update_field(post.bounty_receivers_, properties, "awarded_bounty_users", &parse_array<shallow_user>, &parse_shallow_user);
    update_field(post.comments_, properties, "comments", &parse_array<comment>, &parse_comment);
    update_field(post.has_upvoted_, properties, "upvoted", &parse_bool);
    return post;
}



shallow_user parse_shallow_user(const rapidjson::Value& properties) {
    shallow_user shallow;
    update_field(shallow.type_, properties, "user_type", &parse_user_type);
    update_field(shallow.accept_rate_, properties, "accept_rate", &parse_integer);
    update_field(shallow.name_, properties, "display_name", &parse_string);
    update_field(shallow.url_, properties, "link", &parse_string);
    update_field(shallow.avatar_, properties, "profile_image", &parse_string);
    update_field(shallow.reputation_, properties, "reputation", &parse_integer);
    update_field(shallow.id_, properties, "user_id", &parse_unique_id);
    update_field(shallow.badges_, properties, "badge_counts", &parse_badge_count);
    return shallow;
}



comment parse_comment(const rapidjson::Value& properties) {
    comment remark;
    update_field(remark.id_, properties, "comment_id", &parse_unique_id);
    update_field(remark.creation_, properties, "creation_date", &parse_date);
    update_field(remark.edited_, properties, "edited", &parse_bool);
    update_field(remark.post_id_, properties, "post_id", &parse_unique_id);
    update_field(remark.score_, properties, "score", &parse_integer);
    update_field(remark.owner_, properties, "owner", &parse_shallow_user);
    update_field(remark.reply_to_, properties, "reply_to_user", &parse_shallow_user);
    update_field(remark.content_, properties, "body", &parse_string);
    update_field(remark.content_markdown_, properties, "body_markdown", &parse_string);
    update_field(remark.flag_, properties, "can_flag", &parse_bool);
    update_field(remark.url_, properties, "link", &parse_string);
    update_field(remark.post_type_, properties, "post_type", &parse_post_type);
    update_field(remark.has_upvoted_, properties, "upvoted", &parse_bool);
    return remark;
}



badge parse_badge(const rapidjson::Value& properties) {
    badge pin;
    update_field(pin.amount_, properties, "award_count", &parse_integer);
    update_field(pin.id_, properties, "badge_id", &parse_unique_id);
    update_field(pin.type_, properties, "badge_type", &parse_badge_type);
    update_field(pin.url_, properties, "link", &parse_string);
    update_field(pin.name_, properties, "name", &parse_string);
    update_field(pin.rank_, properties, "rank", &parse_badge_rank);
    update_field(pin.description_, properties, "description", &parse_string);
    update_field(pin.user_, properties, "user", &parse_shallow_user);
    return pin;
}



badge_count parse_badge_count(const rapidjson::Value& properties) {
    badge_count badges;
    update_field(badges.bronze_, properties, "bronze", &parse_integer);
    update_field(badges.silver_, properties, "silver", &parse_integer);
    update_field(badges.gold_, properties, "gold", &parse_integer);
    return badges;
}



question parse_question(const rapidjson::Value& properties) {
    objects::question question;
    update_field(question.accepted_answer_id_, properties, "accepted_answer_id", &parse_unique_id);
    update_field(question.answers_, properties, "answers", &parse_array<answer>, &parse_answer);
    update_field(question.content_, properties, "body", &parse_string);
    update_field(question.content_markdown_, properties, "body_markdown", &parse_string);
    update_field(question.bounty_, properties, "bounty_amount", &parse_integer);
    update_field(question.bounty_end_, properties, "bounty_closes_date", &parse_date);
    update_field(question.bounty_giver_, properties, "bounty_user", &parse_shallow_user);
    update_field(question.close_, properties, "can_close", &parse_bool);
    update_field(question.flag_, properties, "can_flag", &parse_bool);
    update_field(question.close_votes_, properties, "close_vote_count", &parse_integer);
    update_field(question.closed_, properties, "closed_date", &parse_date);
    update_field(question.closed_detail_, properties, "closed_details", &parse_closed_detail);
    update_field(question.close_reason_, properties, "closed_reason", &parse_string);
    update_field(question.comments_, properties, "comments", &parse_array<comment>, &parse_comment);
    update_field(question.community_wiki_, properties, "community_owned_date", &parse_date);
    update_field(question.creation_, properties, "creation_date", &parse_date);
    update_field(question.delete_votes_, properties, "delete_vote_count", &parse_integer);
    update_field(question.downvotes_, properties, "down_vote_count", &parse_integer);
    update_field(question.has_downvoted_, properties, "downvoted", &parse_bool);
    update_field(question.favorites_, properties, "favorite_count", &parse_integer);
    update_field(question.has_favorited_, properties, "favorited", &parse_bool);
    update_field(question.answered_, properties, "is_answered", &parse_bool);
    update_field(question.last_active_, properties, "last_activity_date", &parse_date);
    update_field(question.last_edited_, properties, "last_edit_date", &parse_date);
    update_field(question.last_editor_, properties, "last_editor", &parse_shallow_user);
    update_field(question.url_, properties, "link", &parse_string);
    update_field(question.locked_, properties, "locked_date", &parse_date);
    update_field(question.migrated_from_, properties, "migrated_from", &parse_migration_info);
    update_field(question.migrated_to_, properties, "migrated_to", &parse_migration_info);
    update_field(question.notice_, properties, "notice", &parse_notice);
    update_field(question.owner_, properties, "owner", &parse_shallow_user);
    update_field(question.protect_, properties, "protected_date", &parse_date);
    update_field(question.id_, properties, "question_id", &parse_unique_id);
    update_field(question.reopen_votes_, properties, "reopen_vote_count", &parse_integer);
    update_field(question.score_, properties, "score", &parse_integer);
    update_field(question.share_url_, properties, "share_link", &parse_string);
    update_field(question.tags_, properties, "tags", &parse_array<std::string>, &parse_string);
    update_field(question.title_, properties, "title", &parse_string);
    update_field(question.upvotes_, properties, "up_vote_count", &parse_integer);
    update_field(question.has_upvoted_, properties, "upvoted", &parse_bool);
    update_field(question.views_, properties, "view_count", &parse_integer);
    return question;
}



closed_detail parse_closed_detail(const rapidjson::Value& properties) {
    closed_detail details;
    update_field(details.users_, properties, "by_users", &parse_array<shallow_user>, &parse_shallow_user);
    update_field(details.description_, properties, "description", &parse_string);
    update_field(details.on_hold_, properties, "on_hold", &parse_bool);
    update_field(details.original_questions_, properties, "original_questions", &parse_array<original_question>, &parse_original_question);
    update_field(details.reason_, properties, "reason", &parse_string);
    return details;
}



migration_info parse_migration_info(const rapidjson::Value& properties) {
    migration_info info;
    update_field(info.date_, properties, "on_date", &parse_date);
    update_field(info.other_site_, properties, "other_site", &parse_site);
    update_field(info.question_id_, properties, "question_id", &parse_unique_id);
    return info;
}



notice parse_notice(const rapidjson::Value& properties) {
    notice notice;
    update_field(notice.content_, properties, "body", &parse_string);
    update_field(notice.creation_, properties, "creation_date", &parse_date);
    update_field(notice.owner_id_, properties, "owner_user_id", &parse_unique_id);
    return notice;
}



original_question parse_original_question(const rapidjson::Value& properties) {
    original_question question;
    update_field(question.accepted_answer_id_, properties, "accepted_answer_id", &parse_unique_id);
    update_field(question.answers_, properties, "answer_count", &parse_integer);
    update_field(question.id_, properties, "question_id", &parse_unique_id);
    update_field(question.title_, properties, "title", &parse_string);
    return question;
}



related_site parse_related_site(const rapidjson::Value& properties) {
    related_site site;
    update_field(site.api_site_, properties, "api_site_parameter", &parse_string);
    update_field(site.name_, properties, "name", &parse_string);
    update_field(site.relation_, properties, "relation", &parse_string);
    update_field(site.url_, properties, "site_url", &parse_string);
    return site;
}



site parse_site(const rapidjson::Value& properties) {
    site site;
    update_field(site.aliases_, properties, "aliases", &parse_array<std::string>, &parse_string);
    update_field(site.api_site_, properties, "api_site_parameter", &parse_string);
    update_field(site.audience_, properties, "audience", &parse_string);
    update_field(site.beta_closed_, properties, "closed_beta_date", &parse_date);
    update_field(site.favicon_, properties, "favicon_url", &parse_string);
    update_field(site.icon_high_res_, properties, "high_resolution_icon_url", &parse_string);
    update_field(site.icon_, properties, "icon_url", &parse_string);
    update_field(site.launch_, properties, "launch_date", &parse_date);
    update_field(site.logo_, properties, "logo_url", &parse_string);
    update_field(site.markdown_extensions_, properties, "markdown_extensions", &parse_array<std::string>, &parse_string);
    update_field(site.name_, properties, "name", &parse_string);
    update_field(site.open_beta_, properties, "open_beta_date", &parse_date);
    update_field(site.related_, properties, "related_sites", &parse_array<related_site>, &parse_related_site);
    update_field(site.state_, properties, "site_state", &parse_site_state);
    update_field(site.type_, properties, "site_type", &parse_string);
    update_field(site.url_, properties, "site_url", &parse_string);
    update_field(site.style_, properties, "styling", &parse_styling);
    update_field(site.twitter_, properties, "twitter_account", &parse_string);
    return site;
}



styling parse_styling(const rapidjson::Value& properties) {
    styling style;
    update_field(style.link_color_, properties, "link_color", &parse_string);
    update_field(style.tag_background_color_, properties, "tag_background_color", &parse_string);
    update_field(style.tag_foreground_color_, properties, "tag_foreground_color", &parse_string);
    return style;
}



network_activity parse_network_activity(const rapidjson::Value& properties) {
    network_activity activity;
    update_field(activity.account_id_, properties, "account_id", &parse_unique_id);
    update_field(activity.activity_, properties, "activity_type", &parse_activity_type);
    update_field(activity.api_site_, properties, "api_site_parameter", &parse_string);
    update_field(activity.badge_id_, properties, "badge_id", &parse_unique_id);
    update_field(activity.creation_, properties, "creation_date", &parse_date);
    update_field(activity.description_, properties, "description", &parse_string);
    update_field(activity.url_, properties, "link", &parse_string);
    update_field(activity.post_id_, properties, "post_id", &parse_unique_id);
    update_field(activity.score_, properties, "score", &parse_integer);
    update_field(activity.tags_, properties, "tags", &parse_array<std::string>, &parse_string);
    update_field(activity.title_, properties, "title", &parse_string);
    return activity;
}



notification parse_notification(const rapidjson::Value& properties) {
    objects::notification notification;
    update_field(notification.content_, properties, "body", &parse_string);
    update_field(notification.creation_, properties, "creation_date", &parse_date);
    update_field(notification.unread_, properties, "is_unread", &parse_bool);
    update_field(notification.type_, properties, "notification_type", &parse_notification_type);
    update_field(notification.post_id_, properties, "post_id", &parse_unique_id);
    update_field(notification.site_, properties, "site", &parse_site);
    return notification;
}



post parse_post(const rapidjson::Value& properties) {
    objects::post post;
    update_field(post.content_, properties, "body", &parse_string);
    update_field(post.content_markdown_, properties, "body_markdown", &parse_string);
    update_field(post.comments_, properties, "comments", &parse_array<comment>, &parse_comment);
    update_field(post.creation_, properties, "creation_date", &parse_date);
    update_field(post.downvotes_, properties, "down_vote_count", &parse_integer);
    update_field(post.has_downvoted_, properties, "downvoted", &parse_bool);
    update_field(post.last_active_, properties, "last_activity_date", &parse_date);
    update_field(post.last_edited_, properties, "last_edit_date", &parse_date);
    update_field(post.last_editor_, properties, "last_editor", &parse_shallow_user);
    update_field(post.url_, properties, "link", &parse_string);
    update_field(post.owner_, properties, "owner", &parse_shallow_user);
    update_field(post.id_, properties, "post_id", &parse_unique_id);
    update_field(post.type_, properties, "post_type", &parse_post_type);
    update_field(post.score_, properties, "score", &parse_integer);
    update_field(post.share_url_, properties, "share_link", &parse_string);
    update_field(post.title_, properties, "title", &parse_string);
    update_field(post.upvotes_, properties, "up_vote_count", &parse_integer);
    update_field(post.has_upvoted_, properties, "upvoted", &parse_bool);
    return post;
}



privilege parse_privilege(const rapidjson::Value& properties) {
    objects::privilege privilege;
    update_field(privilege.description_, properties, "description", &parse_string);
    update_field(privilege.reputation_, properties, "reputation", &parse_integer);
    update_field(privilege.short_description_, properties, "short_description", &parse_string);
    return privilege;
}



reputation parse_reputation(const rapidjson::Value& properties) {
    reputation rep;
    update_field(rep.url_, properties, "link", &parse_string);
    update_field(rep.time_, properties, "on_date", &parse_date);
    update_field(rep.post_id_, properties, "post_id", &parse_unique_id);
    update_field(rep.post_type_, properties, "post_type", &parse_post_type);
    update_field(rep.change_, properties, "reputation_change", &parse_integer);
    update_field(rep.title_, properties, "title", &parse_string);
    update_field(rep.user_id_, properties, "user_id", &parse_unique_id);
    update_field(rep.vote_type_, properties, "vote_type", &parse_vote_type);
    return rep;
}



reputation_history parse_reputation_history(const rapidjson::Value& properties) {
    reputation_history history;
    update_field(history.creation_, properties, "creation_date", &parse_date);
    update_field(history.post_id_, properties, "post_id", &parse_unique_id);
    update_field(history.change_, properties, "reputation_change", &parse_integer);
    update_field(history.type_, properties, "reputation_history_type", &parse_reputation_history_type);
    update_field(history.user_id_, properties, "user_id", &parse_unique_id);
    return history;
}



suggested_edit parse_suggested_edit(const rapidjson::Value& properties) {
    suggested_edit edit;
    update_field(edit.approval_, properties, "approval_date", &parse_date);
    update_field(edit.content_, properties, "body", &parse_string);
    update_field(edit.comment_, properties, "comment", &parse_string);
    update_field(edit.creation_, properties, "creation_date", &parse_date);
    update_field(edit.post_id_, properties, "post_id", &parse_unique_id);
    update_field(edit.post_type_, properties, "post_type", &parse_post_type);
    update_field(edit.proposer_, properties, "proposing_user", &parse_shallow_user);
    update_field(edit.rejection_, properties, "rejection_date", &parse_date);
    update_field(edit.id_, properties, "suggested_edit_id", &parse_unique_id);
    update_field(edit.tags_, properties, "tags", &parse_array<std::string>, &parse_string);
    update_field(edit.title_, properties, "title", &parse_string);
    return edit;
}



tag parse_tag(const rapidjson::Value& properties) {
    objects::tag tag;
    update_field(tag.count_, properties, "count", &parse_integer);
    update_field(tag.has_synonyms_, properties, "has_synonyms", &parse_bool);
    update_field(tag.moderator_only_, properties, "is_moderator_only", &parse_bool);
    update_field(tag.required_, properties, "is_required", &parse_bool);
    update_field(tag.last_active_, properties, "last_activity_date", &parse_date);
    update_field(tag.name_, properties, "name", &parse_string);
    update_field(tag.synonyms_, properties, "synonyms", &parse_array<std::string>, &parse_string);
    update_field(tag.user_id_, properties, "user_id", &parse_unique_id);
    return tag;
}



user_timeline parse_user_timeline(const rapidjson::Value& properties) {
    user_timeline timeline;
    update_field(timeline.badge_id_, properties, "badge_id", &parse_unique_id);
    update_field(timeline.comment_id_, properties, "comment_id", &parse_unique_id);
    update_field(timeline.creation_, properties, "creation_date", &parse_date);
    update_field(timeline.detail_, properties, "detail", &parse_string);
    update_field(timeline.url_, properties, "link", &parse_string);
    update_field(timeline.post_id_, properties, "post_id", &parse_unique_id);
    update_field(timeline.post_type_, properties, "post_type", &parse_post_type);
    update_field(timeline.suggested_edit_id_, properties, "suggested_edit_id", &parse_unique_id);
    update_field(timeline.type_, properties, "timeline_type", &parse_user_timeline_type);
    update_field(timeline.title_, properties, "title", &parse_string);
    update_field(timeline.user_id_, properties, "user_id", &parse_unique_id);
    return timeline;
}



top_tag parse_top_tag(const rapidjson::Value& properties) {
    top_tag tag;
    update_field(tag.answers_, properties, "answer_count", &parse_integer);
    update_field(tag.answer_score_, properties, "answer_score", &parse_integer);
    update_field(tag.questions_, properties, "question_count", &parse_integer);
    update_field(tag.question_score_, properties, "question_score", &parse_integer);
    update_field(tag.name_, properties, "tag_name", &parse_string);
    update_field(tag.user_id_, properties, "user_id", &parse_unique_id);
    return tag;
}



inbox_item parse_inbox_item(const rapidjson::Value& properties) {
    inbox_item item;
    update_field(item.answer_id_, properties, "answer_id", &parse_unique_id);
    update_field(item.content_, properties, "body", &parse_string);
    update_field(item.comment_id_, properties, "comment_id", &parse_unique_id);
    update_field(item.creation_, properties, "creation_date", &parse_date);
    update_field(item.unread_, properties, "is_unread", &parse_bool);
    update_field(item.type_, properties, "item_type", &parse_item_type);
    update_field(item.url_, properties, "link", &parse_string);
    update_field(item.question_id_, properties, "question_id", &parse_unique_id);
    update_field(item.site_, properties, "site", &parse_site);
    update_field(item.title_, properties, "title", &parse_string);
    return item;
}



flag_option parse_flag_option(const rapidjson::Value& properties) {
    flag_option flag;
    update_field(flag.count_, properties, "count", &parse_integer);
    update_field(flag.description_, properties, "description", &parse_string);
    update_field(flag.dialog_title_, properties, "dialog_title", &parse_string);
    update_field(flag.has_flagged_, properties, "has_flagged", &parse_bool);
    update_field(flag.id_, properties, "option_id", &parse_unique_id);
    update_field(flag.requires_comment_, properties, "requires_comment", &parse_bool);
    update_field(flag.requires_question_id_, properties, "requires_question_id", &parse_bool);
    update_field(flag.requires_site_, properties, "requires_site", &parse_bool);
    update_field(flag.sub_flags_, properties, "sub_options", &parse_array<flag_option>, &parse_flag_option);
    update_field(flag.title_, properties, "title", &parse_string);
    return flag;
}



event parse_event(const rapidjson::Value& properties) {
    objects::event event;
    update_field(event.creation_, properties, "creation_date", &parse_date);
    update_field(event.id_, properties, "event_id", &parse_unique_id);
    update_field(event.type_, properties, "event_type", &parse_event_type);
    update_field(event.excerpt_, properties, "excerpt", &parse_string);
    update_field(event.url_, properties, "link", &parse_string);
    return event;
}



info parse_info(const rapidjson::Value& properties) {
    objects::info info;
    update_field(info.answers_per_minute_, properties, "answers_per_minute", &parse_decimal);
    update_field(info.api_revision_, properties, "api_revision", &parse_string);
    update_field(info.badges_per_minute_, properties, "badges_per_minute", &parse_decimal);
    update_field(info.new_active_users_, properties, "new_active_users", &parse_integer);
    update_field(info.questions_per_minute_, properties, "questions_per_minute", &parse_decimal);
    update_field(info.site_, properties, "site", &parse_site);
    update_field(info.accepted_, properties, "total_accepted", &parse_integer);
    update_field(info.answers_, properties, "total_answers", &parse_integer);
    update_field(info.badges_, properties, "total_badges", &parse_integer);
    update_field(info.comments_, properties, "total_comments", &parse_integer);
    update_field(info.questions_, properties, "total_questions", &parse_integer);
    update_field(info.unanswered_, properties, "total_unanswered", &parse_integer);
    update_field(info.users_, properties, "total_users", &parse_integer);
    update_field(info.votes_, properties, "total_votes", &parse_integer);
    return info;
}



revision parse_revision(const rapidjson::Value& properties) {
    objects::revision revision;
    update_field(revision.content_, properties, "body", &parse_string);
    update_field(revision.comment_, properties, "comment", &parse_string);
    update_field(revision.creation_, properties, "creation_date", &parse_date);
    update_field(revision.rollback_, properties, "is_rollback", &parse_bool);
    update_field(revision.last_content_, properties, "last_body", &parse_string);
    update_field(revision.last_tags_, properties, "last_tags", &parse_array<std::string>, &parse_string);
    update_field(revision.last_title_, properties, "last_title", &parse_string);
    update_field(revision.post_id_, properties, "post_id", &parse_unique_id);
    update_field(revision.post_type_, properties, "post_type", &parse_post_type);
    update_field(revision.guid_, properties, "revision_guid", &parse_string);
    update_field(revision.index_, properties, "revision_number", &parse_integer);
    update_field(revision.type_, properties, "revision_type", &parse_revision_type);
    update_field(revision.community_wiki_, properties, "set_community_wiki", &parse_bool);
    update_field(revision.tags_, properties, "tags", &parse_array<std::string>, &parse_string);
    update_field(revision.title_, properties, "title", &parse_string);
    update_field(revision.user_, properties, "user", &parse_shallow_user);
    return revision;
}



question_timeline parse_question_timeline(const rapidjson::Value& properties) {
    question_timeline timeline;
    update_field(timeline.comment_id_, properties, "comment_id", &parse_unique_id);
    update_field(timeline.creation_, properties, "creation_date", &parse_date);
    update_field(timeline.downvotes_, properties, "down_vote_count", &parse_integer);
    update_field(timeline.owner_, properties, "owner", &parse_shallow_user);
    update_field(timeline.post_id_, properties, "post_id", &parse_unique_id);
    update_field(timeline.question_id_, properties, "question_id", &parse_unique_id);
    update_field(timeline.revision_guid_, properties, "revision_guid", &parse_string);
    update_field(timeline.type_, properties, "timeline_type", &parse_question_timeline_type);
    update_field(timeline.upvotes_, properties, "up_vote_count", &parse_integer);
    update_field(timeline.user_, properties, "user", &parse_shallow_user);
    return timeline;
}



search_excerpt parse_search_excerpt(const rapidjson::Value& properties) {
    search_excerpt excerpt;
    update_field(excerpt.answers_, properties, "answer_count", &parse_integer);
    update_field(excerpt.answer_id_, properties, "answer_id", &parse_unique_id);
    update_field(excerpt.content_, properties, "body", &parse_string);
    update_field(excerpt.closed_, properties, "closed_date", &parse_date);
    update_field(excerpt.community_wiki_, properties, "community_owned_date", &parse_date);
    update_field(excerpt.creation_, properties, "creation_date", &parse_date);
    update_field(excerpt.equivalent_tag_search_, properties, "equivalent_tag_search", &parse_array<std::string>, &parse_string);
    update_field(excerpt.excerpt_, properties, "excerpt", &parse_string);
    update_field(excerpt.has_accepted_answer_, properties, "has_accepted_answer", &parse_bool);
    update_field(excerpt.accepted_, properties, "is_accepted", &parse_bool);
    update_field(excerpt.answered_, properties, "is_answered", &parse_bool);
    update_field(excerpt.item_type_, properties, "item_type", &parse_post_type);
    update_field(excerpt.last_active_, properties, "last_activity_date", &parse_date);
    update_field(excerpt.last_active_by_, properties, "last_activity_user", &parse_shallow_user);
    update_field(excerpt.locked_, properties, "locked_date", &parse_date);
    update_field(excerpt.owner_, properties, "owner", &parse_shallow_user);
    update_field(excerpt.question_id_, properties, "question_id", &parse_unique_id);
    update_field(excerpt.question_score_, properties, "question_score", &parse_integer);
    update_field(excerpt.score_, properties, "score", &parse_integer);
    update_field(excerpt.tags_, properties, "tags", &parse_array<std::string>, &parse_string);
    update_field(excerpt.title_, properties, "title", &parse_string);
    return excerpt;
}



tag_synonym parse_tag_synonym(const rapidjson::Value& properties) {
    tag_synonym tag;
    update_field(tag.applied_, properties, "applied_count", &parse_integer);
    update_field(tag.creation_, properties, "creation_date", &parse_date);
    update_field(tag.from_, properties, "from_tag", &parse_string);
    update_field(tag.last_applied_, properties, "last_applied_date", &parse_date);
    update_field(tag.to_, properties, "to_tag", &parse_string);
    return tag;
}



tag_score parse_tag_score(const rapidjson::Value& properties) {
    tag_score score;
    update_field(score.amount_, properties, "post_count", &parse_integer);
    update_field(score.score_, properties, "score", &parse_integer);
    update_field(score.user_, properties, "user", &parse_shallow_user);
    return score;
}



tag_wiki parse_tag_wiki(const rapidjson::Value& properties) {
    tag_wiki wiki;
    update_field(wiki.content_, properties, "body", &parse_string);
    update_field(wiki.last_content_edit_, properties, "body_last_edit_date", &parse_date);
    update_field(wiki.excerpt_, properties, "excerpt", &parse_string);
    update_field(wiki.last_excerpt_edit_, properties, "excerpt_last_edit_date", &parse_date);
    update_field(wiki.last_content_editor_, properties, "last_body_editor", &parse_shallow_user);
    update_field(wiki.last_excerpt_editor_, properties, "last_excerpt_editor", &parse_shallow_user);
    update_field(wiki.name_, properties, "tag_name", &parse_string);
    return wiki;
}



access_token parse_access_token(const rapidjson::Value& properties) {
    access_token token;
    update_field(token.token_, properties, "access_token", &parse_string);
    update_field(token.id_, properties, "account_id", &parse_unique_id);
    update_field(token.expires_, properties, "expires_on_date", &parse_date);
    update_field(token.scope_, properties, "scope", &parse_array<std::string>, &parse_string);
    return token;
}



network_user parse_network_user(const rapidjson::Value& properties) {
    network_user user;
    update_field(user.account_id_, properties, "account_id", &parse_unique_id);
    update_field(user.answers_, properties, "answer_count", &parse_integer);
    update_field(user.badges_, properties, "badge_counts", &parse_badge_count);
    update_field(user.creation_, properties, "creation_date", &parse_date);
    update_field(user.last_accessed_, properties, "last_access_date", &parse_date);
    update_field(user.questions_, properties, "question_count", &parse_integer);
    update_field(user.reputation_, properties, "reputation", &parse_integer);
    update_field(user.site_, properties, "site_name", &parse_string);
    update_field(user.site_url_, properties, "site_url", &parse_string);
    update_field(user.top_answers_, properties, "top_answers", &parse_array<network_post>, &parse_network_post);
    update_field(user.top_questions_, properties, "top_questions", &parse_array<network_post>, &parse_network_post);
    update_field(user.id_, properties, "user_id", &parse_unique_id);
    update_field(user.type_, properties, "user_type", &parse_user_type);
    return user;
}



network_post parse_network_post(const rapidjson::Value& properties) {
    network_post post;
    update_field(post.id_, properties, "post_id", &parse_unique_id);
    update_field(post.type_, properties, "post_type", &parse_post_type);
    update_field(post.score_, properties, "score", &parse_integer);
    update_field(post.title_, properties, "title", &parse_string);
    return post;
}



account_merge parse_account_merge(const rapidjson::Value& properties) {
    account_merge merge;
    update_field(merge.merge_, properties, "merge_date", &parse_date);
    update_field(merge.new_account_, properties, "new_account_id", &parse_unique_id);
    update_field(merge.old_account_, properties, "old_account_id", &parse_unique_id);
    return merge;
}
}
